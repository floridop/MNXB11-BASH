BASH=/bin/bash
BASHOPTS=checkwinsize:cmdhist:complete_fullquote:expand_aliases:extglob:extquote:force_fignore:globasciiranges:histappend:interactive_comments:login_shell:progcomp:promptvars:sourcepath
BASHRCSOURCED=Y
BASH_ALIASES=()
BASH_ARGC=([0]="0")
BASH_ARGV=()
BASH_CMDS=()
BASH_COMPLETION_VERSINFO=([0]="2" [1]="11")
BASH_ENV=/usr/share/lmod/lmod/init/bash
BASH_LINENO=()
BASH_REMATCH=()
BASH_SOURCE=()
BASH_VERSINFO=([0]="5" [1]="1" [2]="8" [3]="1" [4]="release" [5]="x86_64-redhat-linux-gnu")
BASH_VERSION='5.1.8(1)-release'
COBBLER_SERVER=10.18.11.9
COLUMNS=204
COMP_WORDBREAKS=$' \t\n"\'><=;|&(:'
DEBUGINFOD_URLS='https://debuginfod.centos.org/ '
DIRSTACK=()
EASYBUILD_PARALLEL=40
EUID=6312
FPATH=/usr/share/lmod/lmod/init/ksh_funcs
GROUPS=()
HISTCONTROL=ignoredups
HISTFILE=/home/pflorido/.bash_history
HISTFILESIZE=1000
HISTSIZE=1000
HISTTIMEFORMAT='%y-%m-%d %T # '
HOME=/home/pflorido
HOSTNAME=cosmos-pkf.int
HOSTTYPE=x86_64
IFS=$' \t\n'
LANG=en_US.UTF-8
LESSOPEN='||/usr/bin/lesspipe.sh %s'
LINES=60
LMOD_CMD=/usr/share/lmod/lmod/libexec/lmod
LMOD_DIR=/usr/share/lmod/lmod/libexec
LMOD_MODULEPATH_INIT=/usr/share/lmod/lmod/init/.modulespath
LMOD_PKG=/usr/share/lmod/lmod
LMOD_RC=/sw/lmod/lmodrc.lua
LMOD_ROOT=/usr/share/lmod
LMOD_SETTARG_FULL_SUPPORT=no
LMOD_SYSTEM_DEFAULT_MODULES=SoftwareTree/Milan
LMOD_VERSION=8.7.55
LMOD_sys=Linux
LOADEDMODULES=SoftwareTree/Milan
LOGNAME=pflorido
LS_COLORS='rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=01;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=01;36:*.au=01;36:*.flac=01;36:*.m4a=01;36:*.mid=01;36:*.midi=01;36:*.mka=01;36:*.mp3=01;36:*.mpc=01;36:*.ogg=01;36:*.ra=01;36:*.wav=01;36:*.oga=01;36:*.opus=01;36:*.spx=01;36:*.xspf=01;36:'
MACHTYPE=x86_64-redhat-linux-gnu
MAIL=/var/spool/mail/pflorido
MAILCHECK=60
MANPATH=/usr/share/lmod/lmod/share/man::/opt/thinlinc/share/man
MODULEPATH=/sw/Modules/modulefiles/Core:/sw/easybuild_milan/modules/all/Core:/etc/scl/modulefiles:/etc/modulefiles:/usr/share/modulefiles:/usr/share/modulefiles/Linux:/usr/share/modulefiles/Core:/usr/share/lmod/lmod/modulefiles/Core
MODULEPATH_ROOT=/sw/Modules/modulefiles:/usr/share/modulefiles
MODULESHOME=/usr/share/Modules
MOTD_SHOWN=pam
OLDPWD=/home/pflorido/git/MNXB11-BASH/exercises
ONDEMAND_DT_DIR=/sw/pkg/gfxlauncher
OPTERR=1
OPTIND=1
OSTYPE=linux-gnu
PATH='/projects/hep/fs10/mnxb11/bin:/home/pflorido/.local/bin:/home/pflorido/bin:/sw/pkg/gfxlauncher:/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:~/bin:.:/sw/pkg/lunarc/bin:/sw/pkg/slurm/local/bin:/opt/thinlinc/bin:/opt/thinlinc/sbin'
PDSH_RCMD_TYPE=ssh
PIPESTATUS=([0]="0")
PPID=264665
PROMPT_COMMAND='printf "\033]0;%s@%s:%s\007" "${USER}" "${HOSTNAME%%.*}" "${PWD/#$HOME/\~}"'
PS1='[\u@\h \W]\$ '
PS2='> '
PS4='+ '
PWD=/home/pflorido/git/MNXB11-BASH/exercises/ex03
REPLY=$'\177ELF\002\001\001\003>\001\220\273@\350{\002@8\r@\036\035\006\004@@@\330\002\330\002\b\003\004\030\003\030\003\030\003\034\034\001\001\004(w(w\020\001\005\200\200\200!4\001!4\001\020\001\004\300\001\300\001\300\001\260\223\260\223\020\001\006\320W\002\320g\002\320g\002\264\030\250\032\020\002\006\340b\002\340r\002\340r\002P\003P\003\b\004\0048\0038\0038\00300\b\004\004h\003h\003h\003DD\004S\345td\0048\0038\0038\00300\bP\345td\004\220.\002\220.\002\220.\002L\004L\004\004Q\345td\006\020R\345td\004\320W\002\320g\002\320g\0020\0300\030\001/lib64/ld-linux-x86-64.so.2\004 \005GNU\002\300\004\003\002\200\300\004\003\004\024\003GNU\242.\036\226\035\223c\311\016a\230\235d\361\021$m\342\313+\004\020\001GNU\003\002\0213\001\004\bD\020\020\024\002\004\004(>-\240@\206E\201\214\006\030%a'
SHELL=/bin/bash
SHELLOPTS=braceexpand:emacs:hashall:histexpand:history:interactive-comments:monitor
SHLVL=1
SNIC_TMP=snic_tmp
SSH_ASKPASS=/usr/libexec/openssh/gnome-ssh-askpass
SSH_CLIENT='10.10.75.69 36810 22'
SSH_CONNECTION='10.10.75.69 36810 194.47.223.133 22'
SSH_TTY=/dev/pts/0
S_COLORS=auto
TERM=xterm-256color
UID=6312
USER=pflorido
XDG_DATA_DIRS=/home/pflorido/.local/share/flatpak/exports/share:/var/lib/flatpak/exports/share:/usr/local/share:/usr/share
_=solution
_LMFILES_=/usr/share/modulefiles/Core/SoftwareTree/Milan.lua
_ModuleTable001_=X01vZHVsZVRhYmxlXyA9IHsKTVR2ZXJzaW9uID0gMywKY19yZWJ1aWxkVGltZSA9IGZhbHNlLApjX3Nob3J0VGltZSA9IGZhbHNlLApkZXB0aFQgPSB7fSwKZmFtaWx5ID0ge30sCm1UID0gewpTb2Z0d2FyZVRyZWUgPSB7CmFjdGlvbkEgPSB7CiJwcmVwZW5kX3BhdGgoXCJNT0RVTEVQQVRIXCIsXCIvc3cvTW9kdWxlcy9tb2R1bGVmaWxlcy9Db3JlOi9zdy9lYXN5YnVpbGRfbWlsYW4vbW9kdWxlcy9hbGwvQ29yZVwiKSIsCn0sCmZuID0gIi91c3Ivc2hhcmUvbW9kdWxlZmlsZXMvQ29yZS9Tb2Z0d2FyZVRyZWUvTWlsYW4ubHVhIiwKZnVsbE5hbWUgPSAiU29mdHdhcmVUcmVlL01pbGFuIiwKbG9hZE9yZGVyID0gMSwKcHJvcFQgPSB7Cmxtb2QgPSB7CnN0aWNreSA9IDEsCn0s
_ModuleTable002_=Cn0sCnN0YWNrRGVwdGggPSAwLApzdGF0dXMgPSAiYWN0aXZlIiwKdXNlck5hbWUgPSAiU29mdHdhcmVUcmVlL01pbGFuIiwKd1YgPSAiKm1pbGFuLip6ZmluYWwiLAp9LAp9LAptcGF0aEEgPSB7CiIvc3cvTW9kdWxlcy9tb2R1bGVmaWxlcy9Db3JlIiwgIi9zdy9lYXN5YnVpbGRfbWlsYW4vbW9kdWxlcy9hbGwvQ29yZSIKLCAiL2V0Yy9zY2wvbW9kdWxlZmlsZXMiLCAiL2V0Yy9tb2R1bGVmaWxlcyIsICIvdXNyL3NoYXJlL21vZHVsZWZpbGVzIgosICIvdXNyL3NoYXJlL21vZHVsZWZpbGVzL0xpbnV4IiwgIi91c3Ivc2hhcmUvbW9kdWxlZmlsZXMvQ29yZSIsICIvdXNyL3NoYXJlL2xtb2QvbG1vZC9tb2R1bGVmaWxlcy9Db3JlIiwKfSwKc3lzdGVtQmFzZU1QQVRIID0gIi9l
_ModuleTable003_=dGMvc2NsL21vZHVsZWZpbGVzOi9ldGMvbW9kdWxlZmlsZXM6L3Vzci9zaGFyZS9tb2R1bGVmaWxlczovdXNyL3NoYXJlL21vZHVsZWZpbGVzL0xpbnV4Oi91c3Ivc2hhcmUvbW9kdWxlZmlsZXMvQ29yZTovdXNyL3NoYXJlL2xtb2QvbG1vZC9tb2R1bGVmaWxlcy9Db3JlIiwKfQo=
_ModuleTable_Sz_=3
__Init_Default_Modules=1
__LMOD_REF_COUNT_MODULEPATH='/sw/Modules/modulefiles/Core:1;/sw/easybuild_milan/modules/all/Core:1;/etc/scl/modulefiles:1;/etc/modulefiles:1;/usr/share/modulefiles:1;/usr/share/modulefiles/Linux:1;/usr/share/modulefiles/Core:1;/usr/share/lmod/lmod/modulefiles/Core:1'
__LMOD_REF_COUNT_MODULEPATH_ROOT='/sw/Modules/modulefiles:1;/usr/share/modulefiles:1'
__git_all_commands=
__git_am_inprogress_options='--skip --continue --resolved --abort --quit --show-current-patch'
__git_cherry_pick_inprogress_options='--continue --quit --abort --skip'
__git_cmds_with_parseopt_helper=
__git_color_moved_opts='no default plain blocks zebra dimmed-zebra'
__git_color_moved_ws_opts=$'no ignore-space-at-eol ignore-space-change\n\t\t\tignore-all-space allow-indentation-change'
__git_config_sections=
__git_config_vars=
__git_diff_algorithms='myers minimal patience histogram'
__git_diff_common_options=$'--stat --numstat --shortstat --summary\n\t\t\t--patch-with-stat --name-only --name-status --color\n\t\t\t--no-color --color-words --no-renames --check\n\t\t\t--color-moved --color-moved= --no-color-moved\n\t\t\t--color-moved-ws= --no-color-moved-ws\n\t\t\t--full-index --binary --abbrev --diff-filter=\n\t\t\t--find-copies --find-object --find-renames\n\t\t\t--no-relative --relative\n\t\t\t--find-copies-harder --ignore-cr-at-eol\n\t\t\t--text --ignore-space-at-eol --ignore-space-change\n\t\t\t--ignore-all-space --ignore-blank-lines --exit-code\n\t\t\t--quiet --ext-diff --no-ext-diff --unified=\n\t\t\t--no-prefix --src-prefix= --dst-prefix=\n\t\t\t--inter-hunk-context= --function-context\n\t\t\t--patience --histogram --minimal\n\t\t\t--raw --word-diff --word-diff-regex=\n\t\t\t--dirstat --dirstat= --dirstat-by-file\n\t\t\t--dirstat-by-file= --cumulative\n\t\t\t--diff-algorithm= --default-prefix\n\t\t\t--submodule --submodule= --ignore-submodules\n\t\t\t--indent-heuristic --no-indent-heuristic\n\t\t\t--textconv --no-textconv --break-rewrites\n\t\t\t--patch --no-patch --cc --combined-all-paths\n\t\t\t--anchored= --compact-summary --ignore-matching-lines=\n\t\t\t--irreversible-delete --line-prefix --no-stat\n\t\t\t--output= --output-indicator-context=\n\t\t\t--output-indicator-new= --output-indicator-old=\n\t\t\t--ws-error-highlight=\n\t\t\t--pickaxe-all --pickaxe-regex\n'
__git_diff_difftool_options=$'--cached --staged\n\t\t\t--base --ours --theirs --no-index --merge-base\n\t\t\t--ita-invisible-in-index --ita-visible-in-index\n\t\t\t--stat --numstat --shortstat --summary\n\t\t\t--patch-with-stat --name-only --name-status --color\n\t\t\t--no-color --color-words --no-renames --check\n\t\t\t--color-moved --color-moved= --no-color-moved\n\t\t\t--color-moved-ws= --no-color-moved-ws\n\t\t\t--full-index --binary --abbrev --diff-filter=\n\t\t\t--find-copies --find-object --find-renames\n\t\t\t--no-relative --relative\n\t\t\t--find-copies-harder --ignore-cr-at-eol\n\t\t\t--text --ignore-space-at-eol --ignore-space-change\n\t\t\t--ignore-all-space --ignore-blank-lines --exit-code\n\t\t\t--quiet --ext-diff --no-ext-diff --unified=\n\t\t\t--no-prefix --src-prefix= --dst-prefix=\n\t\t\t--inter-hunk-context= --function-context\n\t\t\t--patience --histogram --minimal\n\t\t\t--raw --word-diff --word-diff-regex=\n\t\t\t--dirstat --dirstat= --dirstat-by-file\n\t\t\t--dirstat-by-file= --cumulative\n\t\t\t--diff-algorithm= --default-prefix\n\t\t\t--submodule --submodule= --ignore-submodules\n\t\t\t--indent-heuristic --no-indent-heuristic\n\t\t\t--textconv --no-textconv --break-rewrites\n\t\t\t--patch --no-patch --cc --combined-all-paths\n\t\t\t--anchored= --compact-summary --ignore-matching-lines=\n\t\t\t--irreversible-delete --line-prefix --no-stat\n\t\t\t--output= --output-indicator-context=\n\t\t\t--output-indicator-new= --output-indicator-old=\n\t\t\t--ws-error-highlight=\n\t\t\t--pickaxe-all --pickaxe-regex\n'
__git_diff_merges_opts='off none on first-parent 1 separate m combined c dense-combined cc remerge r'
__git_diff_submodule_formats='diff log short'
__git_fetch_recurse_submodules='yes on-demand no'
__git_format_patch_extra_options=$'\n\t--full-index --not --all --no-prefix --src-prefix=\n\t--dst-prefix= --notes\n'
__git_log_common_options=$'\n\t--not --all\n\t--branches --tags --remotes\n\t--first-parent --merges --no-merges\n\t--max-count=\n\t--max-age= --since= --after=\n\t--min-age= --until= --before=\n\t--min-parents= --max-parents=\n\t--no-min-parents --no-max-parents\n'
__git_log_date_formats='relative iso8601 iso8601-strict rfc2822 short local default human raw unix auto: format:'
__git_log_gitk_options=$'\n\t--dense --sparse --full-history\n\t--simplify-merges --simplify-by-decoration\n\t--left-right --notes --no-notes\n'
__git_log_pretty_formats='oneline short medium full fuller reference email raw format: tformat: mboxrd'
__git_log_shortlog_options=$'\n\t--author= --committer= --grep=\n\t--all-match --invert-grep\n'
__git_log_show_options=$'\n\t--diff-merges --diff-merges= --no-diff-merges --dd --remerge-diff\n'
__git_merge_strategies=
__git_merge_strategy_options=$'ours theirs subtree subtree= patience\n\thistogram diff-algorithm= ignore-space-change ignore-all-space\n\tignore-space-at-eol renormalize no-renormalize no-renames\n\tfind-renames find-renames= rename-threshold='
__git_mergetools_common=$'diffuse diffmerge ecmerge emerge kdiff3 meld opendiff\n\t\t\ttkdiff vimdiff nvimdiff gvimdiff xxdiff araxis p4merge\n\t\t\tbc codecompare smerge\n'
__git_patchformat='mbox stgit stgit-series hg mboxrd'
__git_push_recurse_submodules='check on-demand only'
__git_quoted_cr='nowarn warn strip'
__git_rebase_inprogress_options='--continue --skip --abort --quit --show-current-patch'
__git_rebase_interactive_inprogress_options='--continue --skip --abort --quit --show-current-patch --edit-todo'
__git_ref_fieldlist='refname objecttype objectsize objectname upstream push HEAD symref'
__git_revert_inprogress_options='--continue --quit --abort --skip'
__git_send_email_confirm_options='always never auto cc compose'
__git_send_email_suppresscc_options='author self cc bodycc sob cccmd body all'
__git_sequencer_inprogress_options='--continue --quit --abort --skip'
__git_showcurrentpatch='diff raw'
__git_untracked_file_modes='all no normal'
__git_whitespacelist='nowarn warn error error-all fix'
__git_ws_error_highlight_opts='context old new all default'
__lmod_my_status=0
_backup_glob='@(#*#|*@(~|.@(bak|orig|rej|swp|dpkg*|rpm@(orig|new|save))))'
_xspecs=([tex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [freeamp]="!*.@(mp3|ogg|pls|m3u)" [gqmpeg]="!*.@(mp3|ogg|pls|m3u)" [texi2html]="!*.texi*" [hbpp]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [lowriter]="!*.@(sxw|stw|sxg|sgl|doc?([mx])|dot?([mx])|rtf|txt|htm|html|?(f)odt|ott|odm|pdf)" [rpm2cpio]="!*.[rs]pm" [localc]="!*.@(sxc|stc|xls?([bmx])|xlw|xlt?([mx])|[ct]sv|?(f)ods|ots)" [hbrun]="!*.[Hh][Rr][Bb]" [vi]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [latex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [view]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [madplay]="!*.mp3" [compress]="*.Z" [pdfjadetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [pbunzip2]="!*.?(t)bz?(2)" [lrunzip]="!*.lrz" [gunzip]="!*.@(Z|[gGd]z|t[ag]z)" [oowriter]="!*.@(sxw|stw|sxg|sgl|doc?([mx])|dot?([mx])|rtf|txt|htm|html|?(f)odt|ott|odm|pdf)" [epiphany]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [acroread]="!*.[pf]df" [znew]="*.Z" [kwrite]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [xemacs]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [gview]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [lzfgrep]="!*.@(tlz|lzma)" [lzless]="!*.@(tlz|lzma)" [cdiff]="!*.@(dif?(f)|?(d)patch)?(.@([gx]z|bz2|lzma))" [zipinfo]="!*.@(zip|[aegjswx]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|epub|apk|aab|ipa|do[ct][xm]|p[op]t[mx]|xl[st][xm]|pyz|whl)" [pdflatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [portecle]="!@(*.@(ks|jks|jceks|p12|pfx|bks|ubr|gkr|cer|crt|cert|p7b|pkipath|pem|p10|csr|crl)|cacerts)" [modplugplay]="!*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|oct|okt?(a)|p[st]m|s[3t]m|ult|umx|wav|xm)" [lokalize]="!*.po" [lbzcat]="!*.?(t)bz?(2)" [qiv]="!*.@(gif|jp?(e)g|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|svg)" [totem]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmv]|OG[AGMV]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [ps2pdfwr]="!*.@(?(e)ps|pdf)" [dvitype]="!*.dvi" [unpigz]="!*.@(Z|[gGdz]z|t[ag]z)" [mozilla]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [pdfunite]="!*.pdf" [gpdf]="!*.[pf]df" [texi2dvi]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [bunzip2]="!*.?(t)bz?(2)" [zathura]="!*.@(cb[rz7t]|djv?(u)|?(e)ps|pdf)" [kaffeine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmv]|OG[AGMV]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [mpg123]="!*.mp3" [lzegrep]="!*.@(tlz|lzma)" [xv]="!*.@(gif|jp?(e)g?(2)|j2[ck]|jp[2f]|tif?(f)|png|p[bgp]m|bmp|x[bp]m|rle|rgb|pcx|fits|pm|?(e)ps)" [xdvi]="!*.@(dvi|DVI)?(.@(gz|Z|bz2))" [xfig]="!*.fig" [xpdf]="!*.[pf]df" [oobase]="!*.odb" [xelatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [gharbour]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [bzcat]="!*.?(t)bz?(2)" [dragon]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmv]|OG[AGMV]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM|iso|ISO)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [xanim]="!*.@(mpg|mpeg|avi|mov|qt)" [lualatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [rgview]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [rvim]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [xetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [lomath]="!*.@(sxm|smf|mml|odf)" [zcat]="!*.@(Z|[gGd]z|t[ag]z)" [lynx]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [uncompress]="!*.Z" [xzcat]="!*.@(?(t)xz|tlz|lzma)" [vim]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [loimpress]="!*.@(sxi|sti|pps?(x)|ppt?([mx])|pot?([mx])|?(f)odp|otp)" [dvipdf]="!*.dvi" [mpg321]="!*.mp3" [jadetex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [lobase]="!*.odb" [epdfview]="!*.pdf" [ps2pdf14]="!*.@(?(e)ps|pdf)" [ps2pdf13]="!*.@(?(e)ps|pdf)" [ps2pdf12]="!*.@(?(e)ps|pdf)" [poedit]="!*.po" [luatex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [kbabel]="!*.po" [bzme]="!*.@(zip|z|gz|tgz)" [dviselect]="!*.dvi" [realplay]="!*.@(rm?(j)|ra?(m)|smi?(l))" [kdvi]="!*.@(dvi|DVI)?(.@(gz|Z|bz2))" [elinks]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [kghostview]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [gtranslator]="!*.po" [unzip]="!*.@(zip|[aegjswx]ar|exe|pk3|wsz|zargo|xpi|s[tx][cdiw]|sx[gm]|o[dt][tspgfc]|od[bm]|oxt|epub|apk|aab|ipa|do[ct][xm]|p[op]t[mx]|xl[st][xm]|pyz|whl)" [ggv]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [oomath]="!*.@(sxm|smf|mml|odf)" [dvipdfmx]="!*.dvi" [makeinfo]="!*.texi*" [okular]="!*.@(okular|@(?(e|x)ps|?(E|X)PS|[pf]df|[PF]DF|dvi|DVI|cb[rz]|CB[RZ]|djv?(u)|DJV?(U)|dvi|DVI|gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx|GIF|JP?(E)G|MIFF|TIF?(F)|PN[GM]|P[BGP]M|BMP|XPM|ICO|XWD|TGA|PCX|epub|EPUB|odt|ODT|fb?(2)|FB?(2)|mobi|MOBI|g3|G3|chm|CHM)?(.?(gz|GZ|bz2|BZ2|xz|XZ)))" [sxemacs]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [aviplay]="!*.@(avi|asf|wmv)" [rgvim]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [dvipdfm]="!*.dvi" [ly2dvi]="!*.ly" [oodraw]="!*.@(sxd|std|sda|sdd|?(f)odg|otg)" [kpdf]="!*.@(?(e)ps|pdf)" [bibtex]="!*.aux" [netscape]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [emacs]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [rview]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [galeon]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [dillo]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [fbxine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmv]|OG[AGMV]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [oocalc]="!*.@(sxc|stc|xls?([bmx])|xlw|xlt?([mx])|[ct]sv|?(f)ods|ots)" [harbour]="!*.@([Pp][Rr][Gg]|[Cc][Ll][Pp])" [lodraw]="!*.@(sxd|std|sda|sdd|?(f)odg|otg)" [dvips]="!*.dvi" [ps2pdf]="!*.@(?(e)ps|pdf)" [kate]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [kid3-qt]="!*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape)" [pdftex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [gvim]="*.@([ao]|so|so.!(conf|*/*)|[rs]pm|gif|jp?(e)g|mp3|mp?(e)g|avi|asf|ogg|class)" [timidity]="!*.@(mid?(i)|rmi|rcp|[gr]36|g18|mod|xm|it|x3m|s[3t]m|kar)" [ogg123]="!*.@(og[ag]|m3u|flac|spx)" [lzgrep]="!*.@(tlz|lzma)" [ee]="!*.@(gif|jp?(e)g|miff|tif?(f)|pn[gm]|p[bgp]m|bmp|xpm|ico|xwd|tga|pcx)" [unlzma]="!*.@(tlz|lzma)" [lbunzip2]="!*.?(t)bz?(2)" [ooimpress]="!*.@(sxi|sti|pps?(x)|ppt?([mx])|pot?([mx])|?(f)odp|otp)" [xine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmv]|OG[AGMV]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [amaya]="!*.@(?([xX]|[sS])[hH][tT][mM]?([lL]))" [gv]="!*.@(@(?(e)ps|?(E)PS|pdf|PDF)?(.gz|.GZ|.bz2|.BZ2|.Z))" [kid3]="!*.@(mp[234c]|og[ag]|@(fl|a)ac|m4[abp]|spx|tta|w?(a)v|wma|aif?(f)|asf|ape)" [lilypond]="!*.ly" [modplug123]="!*.@(669|abc|am[fs]|d[bs]m|dmf|far|it|mdl|m[eo]d|mid?(i)|mt[2m]|oct|okt?(a)|p[st]m|s[3t]m|ult|umx|wav|xm)" [pbzcat]="!*.?(t)bz?(2)" [unxz]="!*.@(?(t)xz|tlz|lzma)" [playmidi]="!*.@(mid?(i)|cmf)" [lzcat]="!*.@(tlz|lzma)" [slitex]="!*.@(?(la)tex|texi|dtx|ins|ltx|dbj)" [aaxine]="!*@(.@(mp?(e)g|MP?(E)G|wm[av]|WM[AV]|avi|AVI|asf|vob|VOB|bin|dat|divx|DIVX|vcd|ps|pes|fli|flv|FLV|fxm|FXM|viv|rm|ram|yuv|mov|MOV|qt|QT|web[am]|WEB[AM]|mp[234]|MP[234]|m?(p)4[av]|M?(P)4[AV]|mkv|MKV|og[agmv]|OG[AGMV]|t[ps]|T[PS]|m2t?(s)|M2T?(S)|mts|MTS|wav|WAV|flac|FLAC|asx|ASX|mng|MNG|srt|m[eo]d|M[EO]D|s[3t]m|S[3T]M|it|IT|xm|XM)|+([0-9]).@(vdr|VDR))?(.@(crdownload|part))" [advi]="!*.dvi" [lzmore]="!*.@(tlz|lzma)" )
b=refs/heads/2025review
colors=/home/pflorido/.dircolors
cur=
head='ref: refs/heads/2025review'
mpi_selection=
mpi_selector_dir=/var/mpi-selector/data
mpi_selector_homefile=/home/pflorido/.mpi-selector
mpi_selector_sysfile=/etc/sysconfig/mpi-selector
new_dirs=/home/pflorido/.local/share/flatpak/exports/share:/var/lib/flatpak/exports/share
preload__ltrim_colon_completions=true
preload_get_comp_words_by_ref=true
prev=user-find
shell=bash
which_declare='declare -f'
which_opt=-f
___git_complete () 
{ 
    local wrapper="__git_wrap${2}";
    eval "$wrapper () { __git_func_wrap $2 ; }";
    complete -o bashdefault -o default -o nospace -F $wrapper $1 2> /dev/null || complete -o default -o nospace -F $wrapper $1
}
__expand_tilde_by_ref () 
{ 
    if [[ ${!1-} == \~* ]]; then
        eval $1="$(printf ~%q "${!1#\~}")";
    fi
}
__get_cword_at_cursor_by_ref () 
{ 
    local cword words=();
    __reassemble_comp_words_by_ref "$1" words cword;
    local i cur="" index=$COMP_POINT lead=${COMP_LINE:0:COMP_POINT};
    if [[ $index -gt 0 && ( -n $lead && -n ${lead//[[:space:]]/} ) ]]; then
        cur=$COMP_LINE;
        for ((i = 0; i <= cword; ++i))
        do
            while [[ ${#cur} -ge ${#words[i]} && ${cur:0:${#words[i]}} != "${words[i]-}" ]]; do
                cur="${cur:1}";
                ((index > 0)) && ((index--));
            done;
            if ((i < cword)); then
                local old_size=${#cur};
                cur="${cur#"${words[i]}"}";
                local new_size=${#cur};
                ((index -= old_size - new_size));
            fi;
        done;
        [[ -n $cur && ! -n ${cur//[[:space:]]/} ]] && cur=;
        ((index < 0)) && index=0;
    fi;
    local "$2" "$3" "$4" && _upvars -a${#words[@]} $2 ${words+"${words[@]}"} -v $3 "$cword" -v $4 "${cur:0:index}"
}
__git () 
{ 
    git ${__git_C_args:+"${__git_C_args[@]}"} ${__git_dir:+--git-dir="$__git_dir"} "$@" 2> /dev/null
}
__git_aliased_command () 
{ 
    local cur=$1 last list= word cmdline;
    while [[ -n "$cur" ]]; do
        if [[ "$list" == *" $cur "* ]]; then
            return;
        fi;
        cmdline=$(__git config --get "alias.$cur");
        list=" $cur $list";
        last=$cur;
        cur=;
        for word in $cmdline;
        do
            case "$word" in 
                \!gitk | gitk)
                    cur="gitk";
                    break
                ;;
                \!*)
                    : shell command alias
                ;;
                -*)
                    : option
                ;;
                *=*)
                    : setting env
                ;;
                git)
                    : git itself
                ;;
                \(\))
                    : skip parens of shell function definition
                ;;
                {)
                    : skip start of shell helper function
                ;;
                :)
                    : skip null command
                ;;
                \'*)
                    : skip opening quote after sh -c
                ;;
                *)
                    cur="${word%;}";
                    break
                ;;
            esac;
        done;
    done;
    cur=$last;
    if [[ "$cur" != "$1" ]]; then
        echo "$cur";
    fi
}
__git_checkout_default_dwim_mode () 
{ 
    local last_option dwim_opt="--dwim";
    if [ "${GIT_COMPLETION_CHECKOUT_NO_GUESS-}" = "1" ]; then
        dwim_opt="";
    fi;
    if [ -n "$(__git_find_on_cmdline "--no-track")" ]; then
        dwim_opt="";
    fi;
    if [ "$(__git config --type=bool checkout.guess)" = "false" ]; then
        dwim_opt="";
    fi;
    last_option="$(__git_find_last_on_cmdline "--guess --no-guess")";
    case "$last_option" in 
        --guess)
            dwim_opt="--dwim"
        ;;
        --no-guess)
            dwim_opt=""
        ;;
    esac;
    echo "$dwim_opt"
}
__git_complete () 
{ 
    local func;
    if __git_have_func $2; then
        func=$2;
    else
        if __git_have_func __$2_main; then
            func=__$2_main;
        else
            if __git_have_func _$2; then
                func=_$2;
            else
                echo "ERROR: could not find function '$2'" 1>&2;
                return 1;
            fi;
        fi;
    fi;
    ___git_complete $1 $func
}
__git_complete_command () 
{ 
    local command="$1";
    local completion_func="_git_${command//-/_}";
    if ! __git_have_func $completion_func && __git_have_func _completion_loader; then
        _completion_loader "git-$command";
    fi;
    if __git_have_func $completion_func; then
        $completion_func;
        return 0;
    else
        if __git_support_parseopt_helper "$command"; then
            __git_complete_common "$command";
            return 0;
        else
            return 1;
        fi;
    fi
}
__git_complete_common () 
{ 
    local command="$1";
    case "$cur" in 
        --*)
            __gitcomp_builtin "$command"
        ;;
    esac
}
__git_complete_config_variable_name () 
{ 
    local cur_="$cur" sfx;
    while test $# != 0; do
        case "$1" in 
            --cur=*)
                cur_="${1##--cur=}"
            ;;
            --sfx=*)
                sfx="${1##--sfx=}"
            ;;
            *)
                return 1
            ;;
        esac;
        shift;
    done;
    case "$cur_" in 
        branch.*.*)
            local pfx="${cur_%.*}.";
            cur_="${cur_##*.}";
            __gitcomp "remote pushRemote merge mergeOptions rebase" "$pfx" "$cur_" "$sfx";
            return
        ;;
        branch.*)
            local pfx="${cur_%.*}.";
            cur_="${cur_#*.}";
            __gitcomp_direct "$(__git_heads "$pfx" "$cur_" ".")";
            __gitcomp_nl_append 'autoSetupMerge
autoSetupRebase
' "$pfx" "$cur_" "${sfx- }";
            return
        ;;
        guitool.*.*)
            local pfx="${cur_%.*}.";
            cur_="${cur_##*.}";
            __gitcomp "
			argPrompt cmd confirm needsFile noConsole noRescan
			prompt revPrompt revUnmerged title
			" "$pfx" "$cur_" "$sfx";
            return
        ;;
        difftool.*.*)
            local pfx="${cur_%.*}.";
            cur_="${cur_##*.}";
            __gitcomp "cmd path" "$pfx" "$cur_" "$sfx";
            return
        ;;
        man.*.*)
            local pfx="${cur_%.*}.";
            cur_="${cur_##*.}";
            __gitcomp "cmd path" "$pfx" "$cur_" "$sfx";
            return
        ;;
        mergetool.*.*)
            local pfx="${cur_%.*}.";
            cur_="${cur_##*.}";
            __gitcomp "cmd path trustExitCode" "$pfx" "$cur_" "$sfx";
            return
        ;;
        pager.*)
            local pfx="${cur_%.*}.";
            cur_="${cur_#*.}";
            __git_compute_all_commands;
            __gitcomp_nl "$__git_all_commands" "$pfx" "$cur_" "${sfx- }";
            return
        ;;
        remote.*.*)
            local pfx="${cur_%.*}.";
            cur_="${cur_##*.}";
            __gitcomp "
			url proxy fetch push mirror skipDefaultUpdate
			receivepack uploadpack tagOpt pushurl
			" "$pfx" "$cur_" "$sfx";
            return
        ;;
        remote.*)
            local pfx="${cur_%.*}.";
            cur_="${cur_#*.}";
            __gitcomp_nl "$(__git_remotes)" "$pfx" "$cur_" ".";
            __gitcomp_nl_append "pushDefault" "$pfx" "$cur_" "${sfx- }";
            return
        ;;
        url.*.*)
            local pfx="${cur_%.*}.";
            cur_="${cur_##*.}";
            __gitcomp "insteadOf pushInsteadOf" "$pfx" "$cur_" "$sfx";
            return
        ;;
        *.*)
            __git_compute_config_vars;
            __gitcomp "$__git_config_vars" "" "$cur_" "$sfx"
        ;;
        *)
            __git_compute_config_sections;
            __gitcomp "$__git_config_sections" "" "$cur_" "."
        ;;
    esac
}
__git_complete_config_variable_name_and_value () 
{ 
    local cur_="$cur";
    while test $# != 0; do
        case "$1" in 
            --cur=*)
                cur_="${1##--cur=}"
            ;;
            *)
                return 1
            ;;
        esac;
        shift;
    done;
    case "$cur_" in 
        *=*)
            __git_complete_config_variable_value --varname="${cur_%%=*}" --cur="${cur_#*=}"
        ;;
        *)
            __git_complete_config_variable_name --cur="$cur_" --sfx='='
        ;;
    esac
}
__git_complete_config_variable_value () 
{ 
    local varname="$prev" cur_="$cur";
    while test $# != 0; do
        case "$1" in 
            --varname=*)
                varname="${1##--varname=}"
            ;;
            --cur=*)
                cur_="${1##--cur=}"
            ;;
            *)
                return 1
            ;;
        esac;
        shift;
    done;
    if [ "${BASH_VERSINFO[0]:-0}" -ge 4 ]; then
        varname="${varname,,}";
    else
        varname="$(echo "$varname" |tr A-Z a-z)";
    fi;
    case "$varname" in 
        branch.*.remote | branch.*.pushremote)
            __gitcomp_nl "$(__git_remotes)" "" "$cur_";
            return
        ;;
        branch.*.merge)
            __git_complete_refs --cur="$cur_";
            return
        ;;
        branch.*.rebase)
            __gitcomp "false true merges interactive" "" "$cur_";
            return
        ;;
        remote.pushdefault)
            __gitcomp_nl "$(__git_remotes)" "" "$cur_";
            return
        ;;
        remote.*.fetch)
            local remote="${varname#remote.}";
            remote="${remote%.fetch}";
            if [ -z "$cur_" ]; then
                __gitcomp_nl "refs/heads/" "" "" "";
                return;
            fi;
            __gitcomp_nl "$(__git_refs_remotes "$remote")" "" "$cur_";
            return
        ;;
        remote.*.push)
            local remote="${varname#remote.}";
            remote="${remote%.push}";
            __gitcomp_nl "$(__git for-each-ref 			--format='%(refname):%(refname)' refs/heads)" "" "$cur_";
            return
        ;;
        pull.twohead | pull.octopus)
            __git_compute_merge_strategies;
            __gitcomp "$__git_merge_strategies" "" "$cur_";
            return
        ;;
        color.pager)
            __gitcomp "false true" "" "$cur_";
            return
        ;;
        color.*.*)
            __gitcomp "
			normal black red green yellow blue magenta cyan white
			bold dim ul blink reverse
			" "" "$cur_";
            return
        ;;
        color.*)
            __gitcomp "false true always never auto" "" "$cur_";
            return
        ;;
        diff.submodule)
            __gitcomp "$__git_diff_submodule_formats" "" "$cur_";
            return
        ;;
        help.format)
            __gitcomp "man info web html" "" "$cur_";
            return
        ;;
        log.date)
            __gitcomp "$__git_log_date_formats" "" "$cur_";
            return
        ;;
        sendemail.aliasfiletype)
            __gitcomp "mutt mailrc pine elm gnus" "" "$cur_";
            return
        ;;
        sendemail.confirm)
            __gitcomp "$__git_send_email_confirm_options" "" "$cur_";
            return
        ;;
        sendemail.suppresscc)
            __gitcomp "$__git_send_email_suppresscc_options" "" "$cur_";
            return
        ;;
        sendemail.transferencoding)
            __gitcomp "7bit 8bit quoted-printable base64" "" "$cur_";
            return
        ;;
        *.*)
            return
        ;;
    esac
}
__git_complete_fetch_refspecs () 
{ 
    local i remote="$1" pfx="${2-}" cur_="${3-$cur}" sfx="${4- }";
    __gitcomp_direct "$(
		for i in $(__git_refs "$remote" "" "" "$cur_") ; do
			echo "$pfx$i:$i$sfx"
		done
		)"
}
__git_complete_file () 
{ 
    __git_complete_revlist_file
}
__git_complete_force_with_lease () 
{ 
    local cur_=$1;
    case "$cur_" in 
        --*=)

        ;;
        *:*)
            __git_complete_refs --cur="${cur_#*:}"
        ;;
        *)
            __git_complete_refs --cur="$cur_"
        ;;
    esac
}
__git_complete_index_file () 
{ 
    local dequoted_word pfx="" cur_;
    __git_dequote "$cur";
    case "$dequoted_word" in 
        ?*/*)
            pfx="${dequoted_word%/*}/";
            cur_="${dequoted_word##*/}"
        ;;
        *)
            cur_="$dequoted_word"
        ;;
    esac;
    __gitcomp_file_direct "$(__git_index_files "$1" "$pfx" "$cur_")"
}
__git_complete_refs () 
{ 
    local remote= dwim= pfx= cur_="$cur" sfx=" " mode="refs";
    while test $# != 0; do
        case "$1" in 
            --remote=*)
                remote="${1##--remote=}"
            ;;
            --dwim)
                dwim="yes"
            ;;
            --track)
                dwim="yes"
            ;;
            --pfx=*)
                pfx="${1##--pfx=}"
            ;;
            --cur=*)
                cur_="${1##--cur=}"
            ;;
            --sfx=*)
                sfx="${1##--sfx=}"
            ;;
            --mode=*)
                mode="${1##--mode=}"
            ;;
            *)
                return 1
            ;;
        esac;
        shift;
    done;
    case "$mode" in 
        refs)
            __gitcomp_direct "$(__git_refs "$remote" "" "$pfx" "$cur_" "$sfx")"
        ;;
        heads)
            __gitcomp_direct "$(__git_heads "$pfx" "$cur_" "$sfx")"
        ;;
        remote-heads)
            __gitcomp_direct "$(__git_remote_heads "$pfx" "$cur_" "$sfx")"
        ;;
        *)
            return 1
        ;;
    esac;
    if [ "$dwim" = "yes" ]; then
        __gitcomp_direct_append "$(__git_dwim_remote_heads "$pfx" "$cur_" "$sfx")";
    fi
}
__git_complete_remote_or_refspec () 
{ 
    local cur_="$cur" cmd="${words[__git_cmd_idx]}";
    local i c=$((__git_cmd_idx+1)) remote="" pfx="" lhs=1 no_complete_refspec=0;
    if [ "$cmd" = "remote" ]; then
        ((c++));
    fi;
    while [ $c -lt $cword ]; do
        i="${words[c]}";
        case "$i" in 
            --mirror)
                [ "$cmd" = "push" ] && no_complete_refspec=1
            ;;
            -d | --delete)
                [ "$cmd" = "push" ] && lhs=0
            ;;
            --all)
                case "$cmd" in 
                    push)
                        no_complete_refspec=1
                    ;;
                    fetch)
                        return
                    ;;
                    *)

                    ;;
                esac
            ;;
            --multiple)
                no_complete_refspec=1;
                break
            ;;
            -*)

            ;;
            *)
                remote="$i";
                break
            ;;
        esac;
        ((c++));
    done;
    if [ -z "$remote" ]; then
        __gitcomp_nl "$(__git_remotes)";
        return;
    fi;
    if [ $no_complete_refspec = 1 ]; then
        return;
    fi;
    [ "$remote" = "." ] && remote=;
    case "$cur_" in 
        *:*)
            case "$COMP_WORDBREAKS" in 
                *:*)
                    : great
                ;;
                *)
                    pfx="${cur_%%:*}:"
                ;;
            esac;
            cur_="${cur_#*:}";
            lhs=0
        ;;
        +*)
            pfx="+";
            cur_="${cur_#+}"
        ;;
    esac;
    case "$cmd" in 
        fetch)
            if [ $lhs = 1 ]; then
                __git_complete_fetch_refspecs "$remote" "$pfx" "$cur_";
            else
                __git_complete_refs --pfx="$pfx" --cur="$cur_";
            fi
        ;;
        pull | remote)
            if [ $lhs = 1 ]; then
                __git_complete_refs --remote="$remote" --pfx="$pfx" --cur="$cur_";
            else
                __git_complete_refs --pfx="$pfx" --cur="$cur_";
            fi
        ;;
        push)
            if [ $lhs = 1 ]; then
                __git_complete_refs --pfx="$pfx" --cur="$cur_";
            else
                __git_complete_refs --remote="$remote" --pfx="$pfx" --cur="$cur_";
            fi
        ;;
    esac
}
__git_complete_revlist () 
{ 
    __git_complete_revlist_file
}
__git_complete_revlist_file () 
{ 
    local dequoted_word pfx ls ref cur_="$cur";
    case "$cur_" in 
        *..?*:*)
            return
        ;;
        ?*:*)
            ref="${cur_%%:*}";
            cur_="${cur_#*:}";
            __git_dequote "$cur_";
            case "$dequoted_word" in 
                ?*/*)
                    pfx="${dequoted_word%/*}";
                    cur_="${dequoted_word##*/}";
                    ls="$ref:$pfx";
                    pfx="$pfx/"
                ;;
                *)
                    cur_="$dequoted_word";
                    ls="$ref"
                ;;
            esac;
            case "$COMP_WORDBREAKS" in 
                *:*)
                    : great
                ;;
                *)
                    pfx="$ref:$pfx"
                ;;
            esac;
            __gitcomp_file "$(__git ls-tree "$ls" 				| sed 's/^.*	//
				       s/$//')" "$pfx" "$cur_"
        ;;
        *...*)
            pfx="${cur_%...*}...";
            cur_="${cur_#*...}";
            __git_complete_refs --pfx="$pfx" --cur="$cur_"
        ;;
        *..*)
            pfx="${cur_%..*}..";
            cur_="${cur_#*..}";
            __git_complete_refs --pfx="$pfx" --cur="$cur_"
        ;;
        *)
            __git_complete_refs
        ;;
    esac
}
__git_complete_strategy () 
{ 
    __git_compute_merge_strategies;
    case "$prev" in 
        -s | --strategy)
            __gitcomp "$__git_merge_strategies";
            return 0
        ;;
        -X)
            __gitcomp "$__git_merge_strategy_options";
            return 0
        ;;
    esac;
    case "$cur" in 
        --strategy=*)
            __gitcomp "$__git_merge_strategies" "" "${cur##--strategy=}";
            return 0
        ;;
        --strategy-option=*)
            __gitcomp "$__git_merge_strategy_options" "" "${cur##--strategy-option=}";
            return 0
        ;;
    esac;
    return 1
}
__git_complete_symbol () 
{ 
    local tags=tags pfx="" cur_="${cur-}" sfx=" ";
    while test $# != 0; do
        case "$1" in 
            --tags=*)
                tags="${1##--tags=}"
            ;;
            --pfx=*)
                pfx="${1##--pfx=}"
            ;;
            --cur=*)
                cur_="${1##--cur=}"
            ;;
            --sfx=*)
                sfx="${1##--sfx=}"
            ;;
            *)
                return 1
            ;;
        esac;
        shift;
    done;
    if test -r "$tags"; then
        __gitcomp_direct "$(__git_match_ctag "$cur_" "$tags" "$pfx" "$sfx")";
    fi
}
__git_complete_worktree_paths () 
{ 
    local IFS='
';
    __gitcomp_nl "$(git worktree list --porcelain |
		sed -n -e '2,$ s/^worktree //p')"
}
__git_compute_all_commands () 
{ 
    test -n "$__git_all_commands" || __git_all_commands=$(__git --list-cmds=main,others,alias,nohelpers)
}
__git_compute_config_sections () 
{ 
    test -n "$__git_config_sections" || __git_config_sections="$(git help --config-sections-for-completion)"
}
__git_compute_config_vars () 
{ 
    test -n "$__git_config_vars" || __git_config_vars="$(git help --config-for-completion)"
}
__git_compute_merge_strategies () 
{ 
    test -n "$__git_merge_strategies" || __git_merge_strategies=$(__git_list_merge_strategies)
}
__git_config_get_set_variables () 
{ 
    local prevword word config_file= c=$cword;
    while [ $c -gt "$__git_cmd_idx" ]; do
        word="${words[c]}";
        case "$word" in 
            --system | --global | --local | --file=*)
                config_file="$word";
                break
            ;;
            -f | --file)
                config_file="$word $prevword";
                break
            ;;
        esac;
        prevword=$word;
        c=$((--c));
    done;
    __git config $config_file --name-only --list
}
__git_count_arguments () 
{ 
    local word i c=0;
    for ((i=$__git_cmd_idx; i < ${#words[@]}; i++))
    do
        word="${words[i]}";
        case "$word" in 
            --)
                ((c = 0))
            ;;
            "$1")
                ((c = 0))
            ;;
            ?*)
                ((c++))
            ;;
        esac;
    done;
    printf "%d" $c
}
__git_dequote () 
{ 
    local rest="$1" len ch;
    dequoted_word="";
    while test -n "$rest"; do
        len=${#dequoted_word};
        dequoted_word="$dequoted_word${rest%%[\\\'\"]*}";
        rest="${rest:$((${#dequoted_word}-$len))}";
        case "${rest:0:1}" in 
            \\)
                ch="${rest:1:1}";
                case "$ch" in 
                    '
')

                    ;;
                    *)
                        dequoted_word="$dequoted_word$ch"
                    ;;
                esac;
                rest="${rest:2}"
            ;;
            \')
                rest="${rest:1}";
                len=${#dequoted_word};
                dequoted_word="$dequoted_word${rest%%\'*}";
                rest="${rest:$((${#dequoted_word}-$len+1))}"
            ;;
            \")
                rest="${rest:1}";
                while test -n "$rest"; do
                    len=${#dequoted_word};
                    dequoted_word="$dequoted_word${rest%%[\\\"]*}";
                    rest="${rest:$((${#dequoted_word}-$len))}";
                    case "${rest:0:1}" in 
                        \\)
                            ch="${rest:1:1}";
                            case "$ch" in 
                                \" | \\ | \$ | \`)
                                    dequoted_word="$dequoted_word$ch"
                                ;;
                                '
')

                                ;;
                                *)
                                    dequoted_word="$dequoted_word\\$ch"
                                ;;
                            esac;
                            rest="${rest:2}"
                        ;;
                        \")
                            rest="${rest:1}";
                            break
                        ;;
                    esac;
                done
            ;;
        esac;
    done
}
__git_dwim_remote_heads () 
{ 
    local pfx="${1-}" cur_="${2-}" sfx="${3-}";
    local fer_pfx="${pfx//\%/%%}";
    __git for-each-ref --format="$fer_pfx%(refname:strip=3)$sfx" --sort="refname:strip=3" ${GIT_COMPLETION_IGNORE_CASE+--ignore-case} "refs/remotes/*/$cur_*" "refs/remotes/*/$cur_*/**" | uniq -u
}
__git_eread () 
{ 
    test -r "$1" && IFS='
' read -r "$2" < "$1"
}
__git_find_last_on_cmdline () 
{ 
    local word c=$cword show_idx;
    while test $# -gt 1; do
        case "$1" in 
            --show-idx)
                show_idx=y
            ;;
            *)
                return 1
            ;;
        esac;
        shift;
    done;
    local wordlist="$1";
    while [ $c -gt "$__git_cmd_idx" ]; do
        ((c--));
        for word in $wordlist;
        do
            if [ "$word" = "${words[c]}" ]; then
                if [ -n "$show_idx" ]; then
                    echo "$c $word";
                else
                    echo "$word";
                fi;
                return;
            fi;
        done;
    done
}
__git_find_on_cmdline () 
{ 
    local word c="$__git_cmd_idx" show_idx;
    while test $# -gt 1; do
        case "$1" in 
            --show-idx)
                show_idx=y
            ;;
            *)
                return 1
            ;;
        esac;
        shift;
    done;
    local wordlist="$1";
    while [ $c -lt $cword ]; do
        for word in $wordlist;
        do
            if [ "$word" = "${words[c]}" ]; then
                if [ -n "${show_idx-}" ]; then
                    echo "$c $word";
                else
                    echo "$word";
                fi;
                return;
            fi;
        done;
        ((c++));
    done
}
__git_find_repo_path () 
{ 
    if [ -n "${__git_repo_path-}" ]; then
        return;
    fi;
    if [ -n "${__git_C_args-}" ]; then
        __git_repo_path="$(git "${__git_C_args[@]}" 			${__git_dir:+--git-dir="$__git_dir"} 			rev-parse --absolute-git-dir 2>/dev/null)";
    else
        if [ -n "${__git_dir-}" ]; then
            test -d "$__git_dir" && __git_repo_path="$__git_dir";
        else
            if [ -n "${GIT_DIR-}" ]; then
                test -d "$GIT_DIR" && __git_repo_path="$GIT_DIR";
            else
                if [ -d .git ]; then
                    __git_repo_path=.git;
                else
                    __git_repo_path="$(git rev-parse --git-dir 2>/dev/null)";
                fi;
            fi;
        fi;
    fi
}
__git_func_wrap () 
{ 
    local cur words cword prev;
    local __git_cmd_idx=0;
    _get_comp_words_by_ref -n =: cur words cword prev;
    $1
}
__git_get_config_variables () 
{ 
    local section="$1" i IFS='
';
    for i in $(__git config --name-only --get-regexp "^$section\..*");
    do
        echo "${i#$section.}";
    done
}
__git_get_option_value () 
{ 
    local c short_opt long_opt val;
    local result= values config_key word;
    short_opt="$1";
    long_opt="$2";
    values="$3";
    config_key="$4";
    ((c = $cword - 1));
    while [ $c -ge 0 ]; do
        word="${words[c]}";
        for val in $values;
        do
            if [ "$short_opt$val" = "$word" ] || [ "$long_opt$val" = "$word" ]; then
                result="$val";
                break 2;
            fi;
        done;
        ((c--));
    done;
    if [ -n "$config_key" ] && [ -z "$result" ]; then
        result="$(__git config "$config_key")";
    fi;
    echo "$result"
}
__git_has_doubledash () 
{ 
    local c=1;
    while [ $c -lt $cword ]; do
        if [ "--" = "${words[c]}" ]; then
            return 0;
        fi;
        ((c++));
    done;
    return 1
}
__git_have_func () 
{ 
    declare -f -- "$1" > /dev/null 2>&1
}
__git_heads () 
{ 
    local pfx="${1-}" cur_="${2-}" sfx="${3-}";
    __git for-each-ref --format="${pfx//\%/%%}%(refname:strip=2)$sfx" ${GIT_COMPLETION_IGNORE_CASE+--ignore-case} "refs/heads/$cur_*" "refs/heads/$cur_*/**"
}
__git_index_files () 
{ 
    local root="$2" match="$3";
    __git_ls_files_helper "$root" "$1" "${match:-?}" | awk -F / -v pfx="${2//\\/\\\\}" '{
		paths[$1] = 1
	}
	END {
		for (p in paths) {
			if (substr(p, 1, 1) != "\"") {
				# No special characters, easy!
				print pfx p
				continue
			}

			# The path is quoted.
			p = dequote(p)
			if (p == "")
				continue

			# Even when a directory name itself does not contain
			# any special characters, it will still be quoted if
			# any of its (stripped) trailing path components do.
			# Because of this we may have seen the same directory
			# both quoted and unquoted.
			if (p in paths)
				# We have seen the same directory unquoted,
				# skip it.
				continue
			else
				print pfx p
		}
	}
	function dequote(p,    bs_idx, out, esc, esc_idx, dec) {
		# Skip opening double quote.
		p = substr(p, 2)

		# Interpret backslash escape sequences.
		while ((bs_idx = index(p, "\\")) != 0) {
			out = out substr(p, 1, bs_idx - 1)
			esc = substr(p, bs_idx + 1, 1)
			p = substr(p, bs_idx + 2)

			if ((esc_idx = index("abtvfr\"\\", esc)) != 0) {
				# C-style one-character escape sequence.
				out = out substr("\a\b\t\v\f\r\"\\",
						 esc_idx, 1)
			} else if (esc == "n") {
				# Uh-oh, a newline character.
				# We cannot reliably put a pathname
				# containing a newline into COMPREPLY,
				# and the newline would create a mess.
				# Skip this path.
				return ""
			} else {
				# Must be a \nnn octal value, then.
				dec = esc             * 64 + \
				      substr(p, 1, 1) * 8  + \
				      substr(p, 2, 1)
				out = out sprintf("%c", dec)
				p = substr(p, 3)
			}
		}
		# Drop closing double quote, if there is one.
		# (There is not any if this is a directory, as it was
		# already stripped with the trailing path components.)
		if (substr(p, length(p), 1) == "\"")
			out = out substr(p, 1, length(p) - 1)
		else
			out = out p

		return out
	}'
}
__git_is_configured_remote () 
{ 
    local remote;
    for remote in $(__git_remotes);
    do
        if [ "$remote" = "$1" ]; then
            return 0;
        fi;
    done;
    return 1
}
__git_list_merge_strategies () 
{ 
    LANG=C LC_ALL=C git merge -s help 2>&1 | sed -n -e '/[Aa]vailable strategies are: /,/^$/{
		s/\.$//
		s/.*://
		s/^[ 	]*//
		s/[ 	]*$//
		p
	}'
}
__git_ls_files_helper () 
{ 
    if [ "$2" = "--committable" ]; then
        __git -C "$1" -c core.quotePath=false diff-index --name-only --relative HEAD -- "${3//\\/\\\\}*";
    else
        __git -C "$1" -c core.quotePath=false ls-files --exclude-standard $2 -- "${3//\\/\\\\}*";
    fi
}
__git_main () 
{ 
    local i c=1 command __git_dir __git_repo_path;
    local __git_C_args C_args_count=0;
    local __git_cmd_idx;
    while [ $c -lt $cword ]; do
        i="${words[c]}";
        case "$i" in 
            --git-dir=*)
                __git_dir="${i#--git-dir=}"
            ;;
            --git-dir)
                ((c++));
                __git_dir="${words[c]}"
            ;;
            --bare)
                __git_dir="."
            ;;
            --help)
                command="help";
                break
            ;;
            -c | --work-tree | --namespace)
                ((c++))
            ;;
            -C)
                __git_C_args[C_args_count++]=-C;
                ((c++));
                __git_C_args[C_args_count++]="${words[c]}"
            ;;
            -*)

            ;;
            *)
                command="$i";
                __git_cmd_idx="$c";
                break
            ;;
        esac;
        ((c++));
    done;
    if [ -z "${command-}" ]; then
        case "$prev" in 
            --git-dir | -C | --work-tree)
                return
            ;;
            -c)
                __git_complete_config_variable_name_and_value;
                return
            ;;
            --namespace)
                return
            ;;
        esac;
        case "$cur" in 
            --*)
                __gitcomp "
			--paginate
			--no-pager
			--git-dir=
			--bare
			--version
			--exec-path
			--exec-path=
			--html-path
			--man-path
			--info-path
			--work-tree=
			--namespace=
			--no-replace-objects
			--help
			"
            ;;
            *)
                if test -n "${GIT_TESTING_PORCELAIN_COMMAND_LIST-}"; then
                    __gitcomp "$GIT_TESTING_PORCELAIN_COMMAND_LIST";
                else
                    local list_cmds=list-mainporcelain,others,nohelpers,alias,list-complete,config;
                    if test "${GIT_COMPLETION_SHOW_ALL_COMMANDS-}" = "1"; then
                        list_cmds=builtins,$list_cmds;
                    fi;
                    __gitcomp "$(__git --list-cmds=$list_cmds)";
                fi
            ;;
        esac;
        return;
    fi;
    __git_complete_command "$command" && return;
    local expansion=$(__git_aliased_command "$command");
    if [ -n "$expansion" ]; then
        words[1]=$expansion;
        __git_complete_command "$expansion";
    fi
}
__git_match_ctag () 
{ 
    awk -v pfx="${3-}" -v sfx="${4-}" "
		/^${1//\//\\/}/ { print pfx \$1 sfx }
		" "$2"
}
__git_pretty_aliases () 
{ 
    __git_get_config_variables "pretty"
}
__git_pseudoref_exists () 
{ 
    local ref=$1;
    if __git_eread "$__git_repo_path/HEAD" head; then
        b="${head#ref: }";
        if [ "$b" == "refs/heads/.invalid" ]; then
            __git -C "$__git_repo_path" rev-parse --verify --quiet "$ref" 2> /dev/null;
            return $?;
        fi;
    fi;
    [ -f "$__git_repo_path/$ref" ]
}
__git_reassemble_comp_words_by_ref () 
{ 
    local exclude i j first;
    exclude="${1//[^$COMP_WORDBREAKS]}";
    cword_=$COMP_CWORD;
    if [ -z "$exclude" ]; then
        words_=("${COMP_WORDS[@]}");
        return;
    fi;
    for ((i=0, j=0; i < ${#COMP_WORDS[@]}; i++, j++))
    do
        first=t;
        while [ $i -gt 0 ] && [ -n "${COMP_WORDS[$i]}" ] && [ "${COMP_WORDS[$i]//[^$exclude]}" = "${COMP_WORDS[$i]}" ]; do
            if [ $j -ge 2 ] && [ -n "$first" ]; then
                ((j--));
            fi;
            first=;
            words_[$j]=${words_[j]}${COMP_WORDS[i]};
            if [ $i = $COMP_CWORD ]; then
                cword_=$j;
            fi;
            if (($i < ${#COMP_WORDS[@]} - 1)); then
                ((i++));
            else
                return;
            fi;
        done;
        words_[$j]=${words_[j]}${COMP_WORDS[i]};
        if [ $i = $COMP_CWORD ]; then
            cword_=$j;
        fi;
    done
}
__git_refs () 
{ 
    local i hash dir track="${2-}";
    local list_refs_from=path remote="${1-}";
    local format refs;
    local pfx="${3-}" cur_="${4-$cur}" sfx="${5-}";
    local match="${4-}";
    local umatch="${4-}";
    local fer_pfx="${pfx//\%/%%}";
    __git_find_repo_path;
    dir="$__git_repo_path";
    if [ -z "$remote" ]; then
        if [ -z "$dir" ]; then
            return;
        fi;
    else
        if __git_is_configured_remote "$remote"; then
            list_refs_from=remote;
        else
            if [ -d "$remote/.git" ]; then
                dir="$remote/.git";
            else
                if [ -d "$remote" ]; then
                    dir="$remote";
                else
                    list_refs_from=url;
                fi;
            fi;
        fi;
    fi;
    if test "${GIT_COMPLETION_IGNORE_CASE:+1}" = "1"; then
        umatch=$(echo "$match" | tr a-z A-Z 2>/dev/null || echo "$match");
    fi;
    if [ "$list_refs_from" = path ]; then
        if [[ "$cur_" == ^* ]]; then
            pfx="$pfx^";
            fer_pfx="$fer_pfx^";
            cur_=${cur_#^};
            match=${match#^};
            umatch=${umatch#^};
        fi;
        case "$cur_" in 
            refs | refs/*)
                format="refname";
                refs=("$match*" "$match*/**");
                track=""
            ;;
            *)
                for i in HEAD FETCH_HEAD ORIG_HEAD MERGE_HEAD REBASE_HEAD CHERRY_PICK_HEAD REVERT_HEAD BISECT_HEAD AUTO_MERGE;
                do
                    case "$i" in 
                        $match* | $umatch*)
                            if [ -e "$dir/$i" ]; then
                                echo "$pfx$i$sfx";
                            fi
                        ;;
                    esac;
                done;
                format="refname:strip=2";
                refs=("refs/tags/$match*" "refs/tags/$match*/**" "refs/heads/$match*" "refs/heads/$match*/**" "refs/remotes/$match*" "refs/remotes/$match*/**")
            ;;
        esac;
        __git_dir="$dir" __git for-each-ref --format="$fer_pfx%($format)$sfx" ${GIT_COMPLETION_IGNORE_CASE+--ignore-case} "${refs[@]}";
        if [ -n "$track" ]; then
            __git_dwim_remote_heads "$pfx" "$match" "$sfx";
        fi;
        return;
    fi;
    case "$cur_" in 
        refs | refs/*)
            __git ls-remote "$remote" "$match*" | while read -r hash i; do
                case "$i" in 
                    *^{})

                    ;;
                    *)
                        echo "$pfx$i$sfx"
                    ;;
                esac;
            done
        ;;
        *)
            if [ "$list_refs_from" = remote ]; then
                case "HEAD" in 
                    $match* | $umatch*)
                        echo "${pfx}HEAD$sfx"
                    ;;
                esac;
                __git for-each-ref --format="$fer_pfx%(refname:strip=3)$sfx" ${GIT_COMPLETION_IGNORE_CASE+--ignore-case} "refs/remotes/$remote/$match*" "refs/remotes/$remote/$match*/**";
            else
                local query_symref;
                case "HEAD" in 
                    $match* | $umatch*)
                        query_symref="HEAD"
                    ;;
                esac;
                __git ls-remote "$remote" $query_symref "refs/tags/$match*" "refs/heads/$match*" "refs/remotes/$match*" | while read -r hash i; do
                    case "$i" in 
                        *^{})

                        ;;
                        refs/*)
                            echo "$pfx${i#refs/*/}$sfx"
                        ;;
                        *)
                            echo "$pfx$i$sfx"
                        ;;
                    esac;
                done;
            fi
        ;;
    esac
}
__git_refs2 () 
{ 
    local i;
    for i in $(__git_refs "$1");
    do
        echo "$i:$i";
    done
}
__git_refs_remotes () 
{ 
    local i hash;
    __git ls-remote "$1" 'refs/heads/*' | while read -r hash i; do
        echo "$i:refs/remotes/$1/${i#refs/heads/}";
    done
}
__git_remote_heads () 
{ 
    local pfx="${1-}" cur_="${2-}" sfx="${3-}";
    __git for-each-ref --format="${pfx//\%/%%}%(refname:strip=2)$sfx" ${GIT_COMPLETION_IGNORE_CASE+--ignore-case} "refs/remotes/$cur_*" "refs/remotes/$cur_*/**"
}
__git_remotes () 
{ 
    __git_find_repo_path;
    test -d "$__git_repo_path/remotes" && ls --color=auto -1 "$__git_repo_path/remotes";
    __git remote
}
__git_support_parseopt_helper () 
{ 
    test -n "$__git_cmds_with_parseopt_helper" || __git_cmds_with_parseopt_helper="$(__git --list-cmds=parseopt)";
    case " $__git_cmds_with_parseopt_helper " in 
        *" $1 "*)
            return 0
        ;;
        *)
            return 1
        ;;
    esac
}
__git_tags () 
{ 
    local pfx="${1-}" cur_="${2-}" sfx="${3-}";
    __git for-each-ref --format="${pfx//\%/%%}%(refname:strip=2)$sfx" ${GIT_COMPLETION_IGNORE_CASE+--ignore-case} "refs/tags/$cur_*" "refs/tags/$cur_*/**"
}
__git_trailer_tokens () 
{ 
    __git config --name-only --get-regexp '^trailer\..*\.key$' | cut -d. -f 2- | rev | cut -d. -f2- | rev
}
__git_wrap__git_main () 
{ 
    __git_func_wrap __git_main
}
__git_wrap__gitk_main () 
{ 
    __git_func_wrap __gitk_main
}
__gitcomp () 
{ 
    local cur_="${3-$cur}";
    case "$cur_" in 
        *=)

        ;;
        --no-*)
            local c i=0 IFS=' 	
';
            for c in $1;
            do
                if [[ $c == "--" ]]; then
                    continue;
                fi;
                c="$c${4-}";
                if [[ $c == "$cur_"* ]]; then
                    case $c in 
                        --*= | *.)

                        ;;
                        *)
                            c="$c "
                        ;;
                    esac;
                    COMPREPLY[i++]="${2-}$c";
                fi;
            done
        ;;
        *)
            local c i=0 IFS=' 	
';
            for c in $1;
            do
                if [[ $c == "--" ]]; then
                    c="--no-...${4-}";
                    if [[ $c == "$cur_"* ]]; then
                        COMPREPLY[i++]="${2-}$c ";
                    fi;
                    break;
                fi;
                c="$c${4-}";
                if [[ $c == "$cur_"* ]]; then
                    case $c in 
                        *= | *.)

                        ;;
                        *)
                            c="$c "
                        ;;
                    esac;
                    COMPREPLY[i++]="${2-}$c";
                fi;
            done
        ;;
    esac
}
__gitcomp_builtin () 
{ 
    local cmd="$1";
    local incl="${2-}";
    local excl="${3-}";
    local var=__gitcomp_builtin_"${cmd//-/_}";
    local options;
    eval "options=\${$var-}";
    if [ -z "$options" ]; then
        local completion_helper;
        if [ "${GIT_COMPLETION_SHOW_ALL-}" = "1" ]; then
            completion_helper="--git-completion-helper-all";
        else
            completion_helper="--git-completion-helper";
        fi;
        options=" $incl $(__git ${cmd/_/ } $completion_helper) " || return;
        for i in $excl;
        do
            options="${options/ $i / }";
        done;
        eval "$var=\"$options\"";
    fi;
    __gitcomp "$options"
}
__gitcomp_direct () 
{ 
    local IFS='
';
    COMPREPLY=($1)
}
__gitcomp_direct_append () 
{ 
    local IFS='
';
    COMPREPLY+=($1)
}
__gitcomp_directories () 
{ 
    local _tmp_dir _tmp_completions _found=0;
    [[ "$cur" =~ .*/ ]];
    _tmp_dir=$BASH_REMATCH;
    while IFS= read -r -d '' c; do
        if [[ $c == "$cur"* ]]; then
            COMPREPLY+=("$c/");
            _found=1;
        fi;
    done < <(git ls-tree -z -d --name-only HEAD $_tmp_dir);
    if [[ $_found == 0 ]] && [[ "$cur" =~ /$ ]]; then
        __gitcomp_direct_append "$cur ";
    fi
}
__gitcomp_file () 
{ 
    local IFS='
';
    __gitcompadd "$1" "${2-}" "${3-$cur}" "";
    compopt -o filenames +o nospace 2> /dev/null || compgen -f /non-existing-dir/ > /dev/null || true
}
__gitcomp_file_direct () 
{ 
    local IFS='
';
    COMPREPLY=($1);
    compopt -o filenames +o nospace 2> /dev/null || compgen -f /non-existing-dir/ > /dev/null || true
}
__gitcomp_nl () 
{ 
    COMPREPLY=();
    __gitcomp_nl_append "$@"
}
__gitcomp_nl_append () 
{ 
    local IFS='
';
    __gitcompappend "$1" "${2-}" "${3-$cur}" "${4- }"
}
__gitcompadd () 
{ 
    COMPREPLY=();
    __gitcompappend "$@"
}
__gitcompappend () 
{ 
    local x i=${#COMPREPLY[@]};
    for x in $1;
    do
        if [[ "$x" == "$3"* ]]; then
            COMPREPLY[i++]="$2$x$4";
        fi;
    done
}
__gitdir () 
{ 
    if [ -z "${1-}" ]; then
        __git_find_repo_path || return 1;
        echo "$__git_repo_path";
    else
        if [ -d "$1/.git" ]; then
            echo "$1/.git";
        else
            echo "$1";
        fi;
    fi
}
__gitk_main () 
{ 
    __git_has_doubledash && return;
    local __git_repo_path;
    __git_find_repo_path;
    local merge="";
    if __git_pseudoref_exists MERGE_HEAD; then
        merge="--merge";
    fi;
    case "$cur" in 
        --*)
            __gitcomp "
			$__git_log_common_options
			$__git_log_gitk_options
			$merge
			";
            return
        ;;
    esac;
    __git_complete_revlist
}
__hosted_repos () 
{ 
    local predicate="$1";
    local reply=;
    if [ x"$predicate" != x"" ]; then
        reply=$(cvmfs_server list 2>/dev/null | awk "$predicate");
    else
        reply=$(cvmfs_server list 2>/dev/null);
    fi;
    echo "$reply" | awk '{ print $1 }'
}
__load_completion () 
{ 
    local -a dirs=(${BASH_COMPLETION_USER_DIR:-${XDG_DATA_HOME:-$HOME/.local/share}/bash-completion}/completions);
    local ifs=$IFS IFS=: dir cmd="${1##*/}" compfile;
    [[ -n $cmd ]] || return 1;
    for dir in ${XDG_DATA_DIRS:-/usr/local/share:/usr/share};
    do
        dirs+=($dir/bash-completion/completions);
    done;
    IFS=$ifs;
    if [[ $BASH_SOURCE == */* ]]; then
        dirs+=("${BASH_SOURCE%/*}/completions");
    else
        dirs+=(./completions);
    fi;
    local backslash=;
    if [[ $cmd == \\* ]]; then
        cmd="${cmd:1}";
        $(complete -p "$cmd" 2>/dev/null || echo false) "\\$cmd" && return 0;
        backslash=\\;
    fi;
    for dir in "${dirs[@]}";
    do
        [[ -d $dir ]] || continue;
        for compfile in "$cmd" "$cmd.bash" "_$cmd";
        do
            compfile="$dir/$compfile";
            if [[ -f $compfile ]] && . "$compfile" &> /dev/null; then
                [[ -n $backslash ]] && $(complete -p "$cmd") "\\$cmd";
                return 0;
            fi;
        done;
    done;
    [[ -v _xspecs[$cmd] ]] && complete -F _filedir_xspec "$cmd" "$backslash$cmd" && return 0;
    return 1
}
__local_repos () 
{ 
    eval $(grep '^CVMFS_REPOSITORIES=' /etc/cvmfs/default.local);
    __local_repos=$(echo $CVMFS_REPOSITORIES | sed 's/,/ /g' );
    unset CVMFS_REPOSITORIES;
    echo $__local_repos
}
__ltrim_colon_completions () 
{ 
    if [[ $1 == *:* && $COMP_WORDBREAKS == *:* ]]; then
        local colon_word=${1%"${1##*:}"};
        local i=${#COMPREPLY[*]};
        while ((i-- > 0)); do
            COMPREPLY[i]=${COMPREPLY[i]#"$colon_word"};
        done;
    fi
}
__my_reassemble_comp_words_by_ref () 
{ 
    local exclude i j first;
    exclude="${1//[^$COMP_WORDBREAKS]}";
    cword_=$COMP_CWORD;
    if [ -z "$exclude" ]; then
        words_=("${COMP_WORDS[@]}");
        return;
    fi;
    for ((i=0, j=0; i < ${#COMP_WORDS[@]}; i++, j++))
    do
        first=t;
        while [ $i -gt 0 ] && [ -n "${COMP_WORDS[$i]}" ] && [ "${COMP_WORDS[$i]//[^$exclude]}" = "${COMP_WORDS[$i]}" ]; do
            if [ $j -ge 2 ] && [ -n "$first" ]; then
                ((j--));
            fi;
            first=;
            words_[$j]=${words_[j]}${COMP_WORDS[i]};
            if [ $i = $COMP_CWORD ]; then
                cword_=$j;
            fi;
            if (($i < ${#COMP_WORDS[@]} - 1)); then
                ((i++));
            else
                return;
            fi;
        done;
        words_[$j]=${words_[j]}${COMP_WORDS[i]};
        if [ $i = $COMP_CWORD ]; then
            cword_=$j;
        fi;
    done
}
__parse_options () 
{ 
    local option option2 i IFS=' 	
,/|';
    option=;
    local -a array=($1);
    for i in "${array[@]}";
    do
        case "$i" in 
            ---*)
                break
            ;;
            --?*)
                option=$i;
                break
            ;;
            -?*)
                [[ -n $option ]] || option=$i
            ;;
            *)
                break
            ;;
        esac;
    done;
    [[ -n $option ]] || return 0;
    IFS=' 	
';
    if [[ $option =~ (\[((no|dont)-?)\]). ]]; then
        option2=${option/"${BASH_REMATCH[1]}"/};
        option2=${option2%%[<{().[]*};
        printf '%s\n' "${option2/=*/=}";
        option=${option/"${BASH_REMATCH[1]}"/"${BASH_REMATCH[2]}"};
    fi;
    option=${option%%[<{().[]*};
    printf '%s\n' "${option/=*/=}"
}
__perf_main () 
{ 
    local cmd;
    cmd=${words[0]};
    COMPREPLY=();
    __perf_prev_skip_opts;
    if [ -z $prev_skip_opts ]; then
        if [[ $cur == --* ]]; then
            cmds=$($cmd --list-opts);
        else
            cmds=$($cmd --list-cmds);
        fi;
        __perfcomp "$cmds" "$cur";
    else
        if [[ $prev == @("-e"|"--event") && $prev_skip_opts == @(record|stat|top) ]]; then
            local cur1=${COMP_WORDS[COMP_CWORD]};
            local raw_evts=$($cmd list --raw-dump);
            local arr s tmp result cpu_evts;
            if [[ `uname -m` != aarch64 ]]; then
                cpu_evts=$(ls /sys/bus/event_source/devices/cpu/events);
            fi;
            if [[ "$cur1" == */* && ${cur1#*/} =~ ^[A-Z] ]]; then
                OLD_IFS="$IFS";
                IFS=" ";
                arr=($raw_evts);
                IFS="$OLD_IFS";
                for s in ${arr[@]};
                do
                    if [[ "$s" == *cpu/* ]]; then
                        tmp=${s#*cpu/};
                        result=$result" ""cpu/"${tmp^^};
                    else
                        result=$result" "$s;
                    fi;
                done;
                evts=${result}" "${cpu_evts};
            else
                evts=${raw_evts}" "${cpu_evts};
            fi;
            if [[ "$cur1" == , ]]; then
                __perfcomp_colon "$evts" "";
            else
                __perfcomp_colon "$evts" "$cur1";
            fi;
        else
            if [[ $prev_skip_opts == @(kvm|kmem|mem|lock|sched|
			|data|help|script|test|timechart|trace) ]]; then
                subcmds=$($cmd $prev_skip_opts --list-cmds);
                __perfcomp_colon "$subcmds" "$cur";
            fi;
            if [[ $cur == --* ]]; then
                subcmd=$prev_skip_opts;
                __perf_prev_skip_opts $subcmd;
                subcmd=$subcmd" "$prev_skip_opts;
                opts=$($cmd $subcmd --list-opts);
                __perfcomp "$opts" "$cur";
            fi;
        fi;
    fi
}
__perf_prev_skip_opts () 
{ 
    local i cmd_ cmds_;
    let i=cword-1;
    cmds_=$($cmd $1 --list-cmds);
    prev_skip_opts=();
    while [ $i -ge 0 ]; do
        if [[ ${words[i]} == $1 ]]; then
            return;
        fi;
        for cmd_ in $cmds_;
        do
            if [[ ${words[i]} == $cmd_ ]]; then
                prev_skip_opts=${words[i]};
                return;
            fi;
        done;
        ((i--));
    done
}
__perfcomp () 
{ 
    COMPREPLY=($( compgen -W "$1" -- "$2" ))
}
__perfcomp_colon () 
{ 
    __perfcomp "$1" "$2";
    if [ $preload__ltrim_colon_completions = "true" ]; then
        __ltrim_colon_completions $cur;
    else
        __perf__ltrim_colon_completions $cur;
    fi
}
__python_argcomplete_expand_tilde_by_ref () 
{ 
    if [ "${!1:0:1}" = "~" ]; then
        if [ "${!1}" != "${!1//\/}" ]; then
            eval $1="${!1/%\/*}"/'${!1#*/}';
        else
            eval $1="${!1}";
        fi;
    fi
}
__python_argcomplete_run () 
{ 
    if [[ -z "$ARGCOMPLETE_USE_TEMPFILES" ]]; then
        __python_argcomplete_run_inner "$@";
        return;
    fi;
    local tmpfile="$(mktemp)";
    _ARGCOMPLETE_STDOUT_FILENAME="$tmpfile" __python_argcomplete_run_inner "$@";
    local code=$?;
    cat "$tmpfile";
    rm "$tmpfile";
    return $code
}
__python_argcomplete_run_inner () 
{ 
    if [[ -z "$_ARC_DEBUG" ]]; then
        "$@" 8>&1 9>&2 > /dev/null 2>&1;
    else
        "$@" 8>&1 9>&2 1>&9 2>&1;
    fi
}
__python_argcomplete_scan_head () 
{ 
    read -s -r ${3:--N} 1024 < "$1";
    [[ "$REPLY" =~ ${2:-PYTHON_ARGCOMPLETE_OK} ]]
}
__python_argcomplete_scan_head_noerr () 
{ 
    __python_argcomplete_scan_head "$@" 2> /dev/null
}
__reassemble_comp_words_by_ref () 
{ 
    local exclude i j line ref;
    if [[ -n $1 ]]; then
        exclude="[${1//[^$COMP_WORDBREAKS]/}]";
    fi;
    printf -v "$3" %s "$COMP_CWORD";
    if [[ -v exclude ]]; then
        line=$COMP_LINE;
        for ((i = 0, j = 0; i < ${#COMP_WORDS[@]}; i++, j++))
        do
            while [[ $i -gt 0 && ${COMP_WORDS[i]} == +($exclude) ]]; do
                [[ $line != [[:blank:]]* ]] && ((j >= 2)) && ((j--));
                ref="$2[$j]";
                printf -v "$ref" %s "${!ref-}${COMP_WORDS[i]}";
                ((i == COMP_CWORD)) && printf -v "$3" %s "$j";
                line=${line#*"${COMP_WORDS[i]}"};
                [[ $line == [[:blank:]]* ]] && ((j++));
                ((i < ${#COMP_WORDS[@]} - 1)) && ((i++)) || break 2;
            done;
            ref="$2[$j]";
            printf -v "$ref" %s "${!ref-}${COMP_WORDS[i]}";
            line=${line#*"${COMP_WORDS[i]}"};
            ((i == COMP_CWORD)) && printf -v "$3" %s "$j";
        done;
        ((i == COMP_CWORD)) && printf -v "$3" %s "$j";
    else
        for i in "${!COMP_WORDS[@]}";
        do
            printf -v "$2[i]" %s "${COMP_WORDS[i]}";
        done;
    fi
}
__tags () 
{ 
    local reply="";
    for repo in $(__hosted_repos '/stratum0/');
    do
        reply="$(cvmfs_server tag -lx $repo | awk '{print $1}') $reply";
    done;
    echo $reply
}
_allowed_groups () 
{ 
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($(compgen -g -- "$1"));
    else
        local IFS='
 ';
        COMPREPLY=($(compgen -W             "$(id -Gn 2>/dev/null || groups 2>/dev/null)" -- "$1"));
    fi
}
_allowed_users () 
{ 
    if _complete_as_root; then
        local IFS='
';
        COMPREPLY=($(compgen -u -- "${1:-$cur}"));
    else
        local IFS='
 ';
        COMPREPLY=($(compgen -W             "$(id -un 2>/dev/null || whoami 2>/dev/null)" -- "${1:-$cur}"));
    fi
}
_authselect_completions () 
{ 
    local COMMANDS;
    local command;
    local possibleopts;
    function is_valid_command () 
    { 
        local cmd;
        for cmd in "${COMMANDS[@]}";
        do
            if [[ "$cmd" = "$1" ]]; then
                return 0;
            fi;
        done;
        return 1
    };
    function get_command () 
    { 
        local opt;
        if [[ $COMP_CWORD -lt 2 ]]; then
            return;
        fi;
        for opt in "${COMP_WORDS[@]:0:$COMP_CWORD}";
        do
            if is_valid_command "$opt"; then
                echo "$opt";
                return;
            fi;
        done
    };
    function get_command_param () 
    { 
        local havecmd=0;
        local len=${#COMP_WORDS[@]}-1;
        if [[ "$command" = "" ]]; then
            return;
        fi;
        havecmd=0;
        for ((i=0; i<$len; i++ ))
        do
            if [[ "$havecmd" = "1" ]]; then
                if [[ "${COMP_WORDS[$i]}" =~ ^[-=] || "${COMP_WORDS[$i-1]}" = "=" ]]; then
                    continue;
                fi;
                echo "${COMP_WORDS[$i]}";
                return;
            fi;
            if [[ "${COMP_WORDS[$i]}" = "$command" ]]; then
                havecmd=1;
            fi;
        done
    };
    function get_profile () 
    { 
        case "$command" in 
            select | show | requirements | test | list-features)
                get_command_param
            ;;
            enable-feature | disable-feature)
                authselect current 2> /dev/null | head -n1 | cut -d" " -f3
            ;;
        esac
    };
    function get_command_keywords () 
    { 
        local profile;
        case "$command" in 
            select | requirements | test)
                profile="$(get_profile)";
                if [[ "$profile" != "" ]]; then
                    authselect list-features "$profile" 2> /dev/null;
                fi
            ;;
        esac
    };
    function get_command_options () 
    { 
        if [[ "${COMP_WORDS[$COMP_CWORD]}" =~ ^- ]]; then
            case "$command" in 
                select)
                    echo "--force --quiet --nobackup --backup="
                ;;
                apply-changes | disable-feature)
                    echo "--backup="
                ;;
                enable-feature)
                    echo "--backup= --quiet"
                ;;
                current | backup-list)
                    echo "--raw"
                ;;
                create-profile)
                    echo "--vendor --base-on= --base-on-default" "--symlink-meta --symlink-nsswitch --symlink-pam" "--symlink-dconf --symlink="
                ;;
                test)
                    echo "--all --nsswitch --system-auth --password-auth" "--smartcard-auth --fingerprint-auth --postlogin" "--dconf-db --dconf-lock"
                ;;
            esac;
        fi
    };
    function get_global_options () 
    { 
        if [[ "${COMP_WORDS[$COMP_CWORD]}" =~ ^- ]]; then
            echo "--debug --trace --warn --help";
        fi
    };
    function get_option_params () 
    { 
        local opt;
        if [[ $COMP_CWORD -gt 2 && "${COMP_WORDS[$COMP_CWORD-1]}" = "=" ]]; then
            opt="${COMP_WORDS[$COMP_CWORD-2]}";
        else
            if [[ $COMP_CWORD -gt 1 ]]; then
                opt="${COMP_WORDS[$COMP_CWORD-1]}";
            fi;
        fi;
        case "$opt" in 
            --base-on)
                authselect list 2> /dev/null | cut -d" " -f2
            ;;
            --symlink)
                echo "dconf-db dconf-locks fingerprint-auth nsswitch.conf" "password-auth postlogin smartcard-auth system-auth" "README REQUIREMENTS"
            ;;
        esac
    };
    function get_command_params () 
    { 
        local i;
        local profile;
        if [[ "$command" = "" ]]; then
            return;
        fi;
        for ((i=$COMP_CWORD-1; i>1; i-- ))
        do
            opt="${COMP_WORDS[$i]}";
            if [[ "$opt" = "$command" ]]; then
                break;
            fi;
            if [[ "$opt" =~ ^[-=] || "${COMP_WORDS[$i-1]}" = "=" ]]; then
                continue;
            fi;
            return;
        done;
        case "$command" in 
            select | show | requirements | test | list-features)
                authselect list 2> /dev/null | cut -d" " -f2
            ;;
            backup-remove | backup-restore)
                authselect backup-list 2> /dev/null | cut -d" " -f1
            ;;
            enable-feature | disable-feature)
                profile="$(get_profile)";
                if [[ "$profile" != "" ]]; then
                    authselect list-features "$profile" 2> /dev/null;
                fi
            ;;
        esac
    };
    COMMANDS=(select apply-changes list list-features show requirements current check test enable-feature disable-feature create-profile backup-list backup-remove backup-restore);
    possibleopts="$(get_option_params)";
    if [[ "$possibleopts" != "" ]]; then
        if [[ "${COMP_WORDS[$COMP_CWORD]}" = "=" ]]; then
            COMPREPLY=($(compgen -W "$possibleopts"));
        else
            COMPREPLY=($(compgen -W "$possibleopts" -- "${COMP_WORDS[$COMP_CWORD]}"));
        fi;
    else
        command="$(get_command)";
        if [[ "$command" = "" ]]; then
            possibleopts="$(get_global_options) ${COMMANDS[@]}";
        else
            possibleopts="$(get_global_options) $(get_command_params) $(get_command_keywords) $(get_command_options)";
        fi;
        COMPREPLY=($(compgen -W "$possibleopts" -- "${COMP_WORDS[$COMP_CWORD]}"));
    fi
}
_available_interfaces () 
{ 
    local PATH=$PATH:/sbin;
    COMPREPLY=($({
        if [[ ${1:-} == -w ]]; then
            iwconfig
        elif [[ ${1:-} == -a ]]; then
            ifconfig || ip link show up
        else
            ifconfig -a || ip link show
        fi
    } 2>/dev/null | awk         '/^[^ \t]/ { if ($1 ~ /^[0-9]+:/) { print $2 } else { print $1 } }'));
    COMPREPLY=($(compgen -W '${COMPREPLY[@]/%[[:punct:]]/}' -- "$cur"))
}
_bashcomp_try_faketty () 
{ 
    if type unbuffer &> /dev/null; then
        unbuffer -p "$@";
    else
        if script --version 2>&1 | command grep -qF util-linux; then
            script -qaefc "$*" /dev/null;
        else
            "$@";
        fi;
    fi
}
_bpftool () 
{ 
    local cur prev words objword json=0;
    _init_completion || return;
    if [[ ${words[cword]} == -* ]]; then
        local c='--version --json --pretty --bpffs --mapcompat --debug \
            --use-loader --base-btf';
        COMPREPLY=($( compgen -W "$c" -- "$cur" ));
        return 0;
    fi;
    if _bpftool_search_list -j --json -p --pretty; then
        json=1;
    fi;
    case $prev in 
        help | hex)
            return 0
        ;;
        tag)
            _bpftool_get_prog_tags;
            return 0
        ;;
        dev | offload_dev | xdpmeta_dev)
            _sysfs_get_netdevs;
            return 0
        ;;
        file | pinned | -B | --base-btf)
            _filedir;
            return 0
        ;;
        batch)
            COMPREPLY=($( compgen -W 'file' -- "$cur" ));
            return 0
        ;;
    esac;
    local i;
    for ((i=1; i < ${#words[@]}; 1))
    do
        if [[ ${words[i]::1} == - ]] && [[ ${words[i]} != "-B" ]] && [[ ${words[i]} != "--base-btf" ]]; then
            words=("${words[@]:0:i}" "${words[@]:i+1}");
            [[ $i -le $cword ]] && cword=$(( cword - 1 ));
        else
            i=$(( ++i ));
        fi;
    done;
    cur=${words[cword]};
    prev=${words[cword - 1]};
    pprev=${words[cword - 2]};
    local object=${words[1]} command=${words[2]};
    if [[ -z $object || $cword -eq 1 ]]; then
        case $cur in 
            *)
                COMPREPLY=($( compgen -W "$( bpftool help 2>&1 |                     command sed                     -e '/OBJECT := /!d'                     -e 's/.*{//'                     -e 's/}.*//'                     -e 's/|//g' )" -- "$cur" ));
                COMPREPLY+=($( compgen -W 'batch help' -- "$cur" ));
                return 0
            ;;
        esac;
    fi;
    [[ $command == help ]] && return 0;
    case $object in 
        prog)
            case $command in 
                show | list | dump | pin)
                    case $prev in 
                        id)
                            _bpftool_get_prog_ids;
                            return 0
                        ;;
                        name)
                            _bpftool_get_prog_names;
                            return 0
                        ;;
                    esac
                ;;
            esac;
            local PROG_TYPE='id pinned tag name';
            local MAP_TYPE='id pinned name';
            local METRIC_TYPE='cycles instructions l1d_loads llc_misses \
                itlb_misses dtlb_misses';
            case $command in 
                show | list)
                    [[ $prev != "$command" ]] && return 0;
                    COMPREPLY=($( compgen -W "$PROG_TYPE" -- "$cur" ));
                    return 0
                ;;
                dump)
                    case $prev in 
                        $command)
                            COMPREPLY+=($( compgen -W "xlated jited" --                                 "$cur" ));
                            return 0
                        ;;
                        xlated | jited)
                            COMPREPLY=($( compgen -W "$PROG_TYPE" --                                 "$cur" ));
                            return 0
                        ;;
                        *)
                            if _bpftool_search_list 'file'; then
                                return 0;
                            fi;
                            if ! _bpftool_search_list 'linum opcodes visual'; then
                                _bpftool_once_attr 'file';
                            fi;
                            _bpftool_once_attr 'linum opcodes';
                            if _bpftool_search_list 'xlated' && [[ "$json" == 0 ]]; then
                                _bpftool_once_attr 'visual';
                            fi;
                            return 0
                        ;;
                    esac
                ;;
                pin)
                    if [[ $prev == "$command" ]]; then
                        COMPREPLY=($( compgen -W "$PROG_TYPE" -- "$cur" ));
                    else
                        _filedir;
                    fi;
                    return 0
                ;;
                attach | detach)
                    case $cword in 
                        3)
                            COMPREPLY=($( compgen -W "$PROG_TYPE" -- "$cur" ));
                            return 0
                        ;;
                        4)
                            case $prev in 
                                id)
                                    _bpftool_get_prog_ids
                                ;;
                                name)
                                    _bpftool_get_prog_names
                                ;;
                                pinned)
                                    _filedir
                                ;;
                            esac;
                            return 0
                        ;;
                        5)
                            local BPFTOOL_PROG_ATTACH_TYPES='sk_msg_verdict \
                                sk_skb_verdict sk_skb_stream_verdict sk_skb_stream_parser \
                                flow_dissector';
                            COMPREPLY=($( compgen -W "$BPFTOOL_PROG_ATTACH_TYPES" -- "$cur" ));
                            return 0
                        ;;
                        6)
                            COMPREPLY=($( compgen -W "$MAP_TYPE" -- "$cur" ));
                            return 0
                        ;;
                        7)
                            case $prev in 
                                id)
                                    _bpftool_get_map_ids
                                ;;
                                name)
                                    _bpftool_get_map_names
                                ;;
                                pinned)
                                    _filedir
                                ;;
                            esac;
                            return 0
                        ;;
                    esac
                ;;
                load | loadall)
                    local obj;
                    if [[ ${#words[@]} -eq 3 ]]; then
                        COMPREPLY=($( compgen -W "load loadall" -- "$cur" ));
                        return 0;
                    fi;
                    if [[ ${#words[@]} -lt 6 ]]; then
                        _filedir;
                        return 0;
                    fi;
                    obj=${words[3]};
                    if [[ ${words[-4]} == "map" ]]; then
                        COMPREPLY=($( compgen -W "id pinned" -- "$cur" ));
                        return 0;
                    fi;
                    if [[ ${words[-3]} == "map" ]]; then
                        if [[ ${words[-2]} == "idx" ]]; then
                            _bpftool_get_obj_map_idxs $obj;
                        else
                            if [[ ${words[-2]} == "name" ]]; then
                                _bpftool_get_obj_map_names $obj;
                            fi;
                        fi;
                        return 0;
                    fi;
                    if [[ ${words[-2]} == "map" ]]; then
                        COMPREPLY=($( compgen -W "idx name" -- "$cur" ));
                        return 0;
                    fi;
                    case $prev in 
                        type)
                            local BPFTOOL_PROG_LOAD_TYPES='socket kprobe \
                                kretprobe classifier flow_dissector \
                                action tracepoint raw_tracepoint \
                                xdp perf_event cgroup/skb cgroup/sock \
                                cgroup/dev lwt_in lwt_out lwt_xmit \
                                lwt_seg6local sockops sk_skb sk_msg \
                                lirc_mode2 cgroup/bind4 cgroup/bind6 \
                                cgroup/connect4 cgroup/connect6 \
                                cgroup/getpeername4 cgroup/getpeername6 \
                                cgroup/getsockname4 cgroup/getsockname6 \
                                cgroup/sendmsg4 cgroup/sendmsg6 \
                                cgroup/recvmsg4 cgroup/recvmsg6 \
                                cgroup/post_bind4 cgroup/post_bind6 \
                                cgroup/sysctl cgroup/getsockopt \
                                cgroup/setsockopt cgroup/sock_release struct_ops \
                                fentry fexit freplace sk_lookup';
                            COMPREPLY=($( compgen -W "$BPFTOOL_PROG_LOAD_TYPES" -- "$cur" ));
                            return 0
                        ;;
                        id)
                            _bpftool_get_map_ids;
                            return 0
                        ;;
                        name)
                            _bpftool_get_map_names;
                            return 0
                        ;;
                        pinned | pinmaps)
                            _filedir;
                            return 0
                        ;;
                        *)
                            COMPREPLY=($( compgen -W "map" -- "$cur" ));
                            _bpftool_once_attr 'type pinmaps autoattach';
                            _bpftool_one_of_list 'offload_dev xdpmeta_dev';
                            return 0
                        ;;
                    esac
                ;;
                tracelog)
                    return 0
                ;;
                profile)
                    case $cword in 
                        3)
                            COMPREPLY=($( compgen -W "$PROG_TYPE" -- "$cur" ));
                            return 0
                        ;;
                        4)
                            case $prev in 
                                id)
                                    _bpftool_get_prog_ids
                                ;;
                                name)
                                    _bpftool_get_prog_names
                                ;;
                                pinned)
                                    _filedir
                                ;;
                            esac;
                            return 0
                        ;;
                        5)
                            COMPREPLY=($( compgen -W "$METRIC_TYPE duration" -- "$cur" ));
                            return 0
                        ;;
                        6)
                            case $prev in 
                                duration)
                                    return 0
                                ;;
                                *)
                                    COMPREPLY=($( compgen -W "$METRIC_TYPE" -- "$cur" ));
                                    return 0
                                ;;
                            esac;
                            return 0
                        ;;
                        *)
                            COMPREPLY=($( compgen -W "$METRIC_TYPE" -- "$cur" ));
                            return 0
                        ;;
                    esac
                ;;
                run)
                    if [[ ${#words[@]} -eq 4 ]]; then
                        COMPREPLY=($( compgen -W "$PROG_TYPE" -- "$cur" ));
                        return 0;
                    fi;
                    case $prev in 
                        id)
                            _bpftool_get_prog_ids;
                            return 0
                        ;;
                        name)
                            _bpftool_get_prog_names;
                            return 0
                        ;;
                        data_in | data_out | ctx_in | ctx_out)
                            _filedir;
                            return 0
                        ;;
                        repeat | data_size_out | ctx_size_out)
                            return 0
                        ;;
                        *)
                            _bpftool_once_attr 'data_in data_out data_size_out \
                                ctx_in ctx_out ctx_size_out repeat';
                            return 0
                        ;;
                    esac
                ;;
                *)
                    [[ $prev == $object ]] && COMPREPLY=($( compgen -W 'dump help pin attach detach \
                            load loadall show list tracelog run profile' -- "$cur" ))
                ;;
            esac
        ;;
        struct_ops)
            local STRUCT_OPS_TYPE='id name';
            case $command in 
                show | list | dump | unregister)
                    case $prev in 
                        $command)
                            COMPREPLY=($( compgen -W "$STRUCT_OPS_TYPE" -- "$cur" ))
                        ;;
                        id)
                            _bpftool_get_map_ids_for_type struct_ops
                        ;;
                        name)
                            _bpftool_get_map_names_for_type struct_ops
                        ;;
                    esac;
                    return 0
                ;;
                register)
                    _filedir;
                    return 0
                ;;
                *)
                    [[ $prev == $object ]] && COMPREPLY=($( compgen -W 'register unregister show list dump help'                             -- "$cur" ))
                ;;
            esac
        ;;
        iter)
            case $command in 
                pin)
                    case $prev in 
                        $command)
                            _filedir
                        ;;
                        id)
                            _bpftool_get_map_ids
                        ;;
                        name)
                            _bpftool_get_map_names
                        ;;
                        pinned)
                            _filedir
                        ;;
                        *)
                            _bpftool_one_of_list $MAP_TYPE
                        ;;
                    esac;
                    return 0
                ;;
                *)
                    [[ $prev == $object ]] && COMPREPLY=($( compgen -W 'pin help'                             -- "$cur" ))
                ;;
            esac
        ;;
        map)
            local MAP_TYPE='id pinned name';
            case $command in 
                show | list | dump | peek | pop | dequeue | freeze)
                    case $prev in 
                        $command)
                            COMPREPLY=($( compgen -W "$MAP_TYPE" -- "$cur" ));
                            return 0
                        ;;
                        id)
                            case "$command" in 
                                peek)
                                    _bpftool_get_map_ids_for_type stack;
                                    _bpftool_get_map_ids_for_type queue
                                ;;
                                pop)
                                    _bpftool_get_map_ids_for_type stack
                                ;;
                                dequeue)
                                    _bpftool_get_map_ids_for_type queue
                                ;;
                                *)
                                    _bpftool_get_map_ids
                                ;;
                            esac;
                            return 0
                        ;;
                        name)
                            case "$command" in 
                                peek)
                                    _bpftool_get_map_names_for_type stack;
                                    _bpftool_get_map_names_for_type queue
                                ;;
                                pop)
                                    _bpftool_get_map_names_for_type stack
                                ;;
                                dequeue)
                                    _bpftool_get_map_names_for_type queue
                                ;;
                                *)
                                    _bpftool_get_map_names
                                ;;
                            esac;
                            return 0
                        ;;
                        *)
                            return 0
                        ;;
                    esac
                ;;
                create)
                    case $prev in 
                        $command)
                            _filedir;
                            return 0
                        ;;
                        type)
                            local BPFTOOL_MAP_CREATE_TYPES="$(bpftool feature list_builtins map_types 2>/dev/null |                                 grep -v '^unspec$')";
                            COMPREPLY=($( compgen -W "$BPFTOOL_MAP_CREATE_TYPES" -- "$cur" ));
                            return 0
                        ;;
                        key | value | flags | entries)
                            return 0
                        ;;
                        inner_map)
                            COMPREPLY=($( compgen -W "$MAP_TYPE" -- "$cur" ));
                            return 0
                        ;;
                        id)
                            _bpftool_get_map_ids
                        ;;
                        name)
                            case $pprev in 
                                inner_map)
                                    _bpftool_get_map_names
                                ;;
                                *)
                                    return 0
                                ;;
                            esac
                        ;;
                        *)
                            _bpftool_once_attr 'type key value entries name flags offload_dev';
                            if _bpftool_search_list 'array_of_maps' 'hash_of_maps'; then
                                _bpftool_once_attr 'inner_map';
                            fi;
                            return 0
                        ;;
                    esac
                ;;
                lookup | getnext | delete)
                    case $prev in 
                        $command)
                            COMPREPLY=($( compgen -W "$MAP_TYPE" -- "$cur" ));
                            return 0
                        ;;
                        id)
                            _bpftool_get_map_ids;
                            return 0
                        ;;
                        name)
                            _bpftool_get_map_names;
                            return 0
                        ;;
                        key)
                            COMPREPLY+=($( compgen -W 'hex' -- "$cur" ))
                        ;;
                        *)
                            case $(_bpftool_map_guess_map_type) in 
                                queue | stack)
                                    return 0
                                ;;
                            esac;
                            _bpftool_once_attr 'key';
                            return 0
                        ;;
                    esac
                ;;
                update | push | enqueue)
                    case $prev in 
                        $command)
                            COMPREPLY=($( compgen -W "$MAP_TYPE" -- "$cur" ));
                            return 0
                        ;;
                        id)
                            _bpftool_map_update_get_id $command;
                            return 0
                        ;;
                        name)
                            _bpftool_map_update_get_name $command;
                            return 0
                        ;;
                        key)
                            COMPREPLY+=($( compgen -W 'hex' -- "$cur" ))
                        ;;
                        value)
                            case "$(_bpftool_map_guess_map_type)" in 
                                array_of_maps | hash_of_maps)
                                    local MAP_TYPE='id pinned name';
                                    COMPREPLY+=($( compgen -W "$MAP_TYPE"                                         -- "$cur" ));
                                    return 0
                                ;;
                                prog_array)
                                    local PROG_TYPE='id pinned tag name';
                                    COMPREPLY+=($( compgen -W "$PROG_TYPE"                                         -- "$cur" ));
                                    return 0
                                ;;
                                *)
                                    COMPREPLY+=($( compgen -W 'hex'                                         -- "$cur" ));
                                    return 0
                                ;;
                            esac;
                            return 0
                        ;;
                        *)
                            case $(_bpftool_map_guess_map_type) in 
                                queue | stack)
                                    _bpftool_once_attr 'value';
                                    return 0
                                ;;
                            esac;
                            _bpftool_once_attr 'key';
                            local UPDATE_FLAGS='any exist noexist';
                            for ((idx=3; idx < ${#words[@]}-1; idx++ ))
                            do
                                if [[ ${words[idx]} == 'value' ]]; then
                                    _bpftool_one_of_list "$UPDATE_FLAGS";
                                    return 0;
                                fi;
                            done;
                            for ((idx=3; idx < ${#words[@]}-1; idx++ ))
                            do
                                if [[ ${words[idx]} == 'key' ]]; then
                                    _bpftool_once_attr 'value';
                                    return 0;
                                fi;
                            done;
                            return 0
                        ;;
                    esac
                ;;
                pin)
                    case $prev in 
                        $command)
                            COMPREPLY=($( compgen -W "$MAP_TYPE" -- "$cur" ))
                        ;;
                        id)
                            _bpftool_get_map_ids
                        ;;
                        name)
                            _bpftool_get_map_names
                        ;;
                    esac;
                    return 0
                ;;
                event_pipe)
                    case $prev in 
                        $command)
                            COMPREPLY=($( compgen -W "$MAP_TYPE" -- "$cur" ));
                            return 0
                        ;;
                        id)
                            _bpftool_get_map_ids_for_type perf_event_array;
                            return 0
                        ;;
                        name)
                            _bpftool_get_map_names_for_type perf_event_array;
                            return 0
                        ;;
                        cpu)
                            return 0
                        ;;
                        index)
                            return 0
                        ;;
                        *)
                            _bpftool_once_attr 'cpu index';
                            return 0
                        ;;
                    esac
                ;;
                *)
                    [[ $prev == $object ]] && COMPREPLY=($( compgen -W 'delete dump getnext help \
                            lookup pin event_pipe show list update create \
                            peek push enqueue pop dequeue freeze' --                             "$cur" ))
                ;;
            esac
        ;;
        btf)
            local PROG_TYPE='id pinned tag name';
            local MAP_TYPE='id pinned name';
            case $command in 
                dump)
                    case $prev in 
                        $command)
                            COMPREPLY+=($( compgen -W "id map prog file" --                                 "$cur" ));
                            return 0
                        ;;
                        prog)
                            COMPREPLY=($( compgen -W "$PROG_TYPE" -- "$cur" ));
                            return 0
                        ;;
                        map)
                            COMPREPLY=($( compgen -W "$MAP_TYPE" -- "$cur" ));
                            return 0
                        ;;
                        id)
                            case $pprev in 
                                prog)
                                    _bpftool_get_prog_ids
                                ;;
                                map)
                                    _bpftool_get_map_ids
                                ;;
                                $command)
                                    _bpftool_get_btf_ids
                                ;;
                            esac;
                            return 0
                        ;;
                        name)
                            case $pprev in 
                                prog)
                                    _bpftool_get_prog_names
                                ;;
                                map)
                                    _bpftool_get_map_names
                                ;;
                            esac;
                            return 0
                        ;;
                        format)
                            COMPREPLY=($( compgen -W "c raw" -- "$cur" ))
                        ;;
                        *)
                            case ${words[3]} in 
                                id | file)
                                    _bpftool_once_attr 'format'
                                ;;
                                map | prog)
                                    if [[ ${words[3]} == "map" ]] && [[ $cword == 6 ]]; then
                                        COMPREPLY+=($( compgen -W "key value kv all" -- "$cur" ));
                                    fi;
                                    _bpftool_once_attr 'format'
                                ;;
                                *)

                                ;;
                            esac;
                            return 0
                        ;;
                    esac
                ;;
                show | list)
                    case $prev in 
                        $command)
                            COMPREPLY+=($( compgen -W "id" -- "$cur" ))
                        ;;
                        id)
                            _bpftool_get_btf_ids
                        ;;
                    esac;
                    return 0
                ;;
                *)
                    [[ $prev == $object ]] && COMPREPLY=($( compgen -W 'dump help show list'                             -- "$cur" ))
                ;;
            esac
        ;;
        gen)
            case $command in 
                object)
                    _filedir;
                    return 0
                ;;
                skeleton)
                    case $prev in 
                        $command)
                            _filedir;
                            return 0
                        ;;
                        *)
                            _bpftool_once_attr 'name';
                            return 0
                        ;;
                    esac
                ;;
                subskeleton)
                    case $prev in 
                        $command)
                            _filedir;
                            return 0
                        ;;
                        *)
                            _bpftool_once_attr 'name';
                            return 0
                        ;;
                    esac
                ;;
                min_core_btf)
                    _filedir;
                    return 0
                ;;
                *)
                    [[ $prev == $object ]] && COMPREPLY=($( compgen -W 'object skeleton subskeleton help min_core_btf' -- "$cur" ))
                ;;
            esac
        ;;
        cgroup)
            case $command in 
                show | list | tree)
                    case $cword in 
                        3)
                            _filedir
                        ;;
                        4)
                            COMPREPLY=($( compgen -W 'effective' -- "$cur" ))
                        ;;
                    esac;
                    return 0
                ;;
                attach | detach)
                    local BPFTOOL_CGROUP_ATTACH_TYPES="$(bpftool feature list_builtins attach_types 2>/dev/null |                         grep '^cgroup_')";
                    local ATTACH_FLAGS='multi override';
                    local PROG_TYPE='id pinned tag name';
                    if [ $prev = $command ]; then
                        _filedir;
                        return 0;
                    else
                        if [[ $BPFTOOL_CGROUP_ATTACH_TYPES =~ $prev ]]; then
                            COMPREPLY=($( compgen -W "$PROG_TYPE" --                                 "$cur" ));
                            return 0;
                        fi;
                    fi;
                    case $prev in 
                        id)
                            _bpftool_get_prog_ids;
                            return 0
                        ;;
                        *)
                            if ! _bpftool_search_list "$BPFTOOL_CGROUP_ATTACH_TYPES"; then
                                COMPREPLY=($( compgen -W                                     "$BPFTOOL_CGROUP_ATTACH_TYPES" -- "$cur" ));
                            else
                                if [[ "$command" == "attach" ]]; then
                                    _bpftool_one_of_list "$ATTACH_FLAGS";
                                fi;
                            fi;
                            return 0
                        ;;
                    esac
                ;;
                *)
                    [[ $prev == $object ]] && COMPREPLY=($( compgen -W 'help attach detach \
                            show list tree' -- "$cur" ))
                ;;
            esac
        ;;
        perf)
            case $command in 
                *)
                    [[ $prev == $object ]] && COMPREPLY=($( compgen -W 'help \
                            show list' -- "$cur" ))
                ;;
            esac
        ;;
        net)
            local PROG_TYPE='id pinned tag name';
            local ATTACH_TYPES='xdp xdpgeneric xdpdrv xdpoffload';
            case $command in 
                show | list)
                    [[ $prev != "$command" ]] && return 0;
                    COMPREPLY=($( compgen -W 'dev' -- "$cur" ));
                    return 0
                ;;
                attach)
                    case $cword in 
                        3)
                            COMPREPLY=($( compgen -W "$ATTACH_TYPES" -- "$cur" ));
                            return 0
                        ;;
                        4)
                            COMPREPLY=($( compgen -W "$PROG_TYPE" -- "$cur" ));
                            return 0
                        ;;
                        5)
                            case $prev in 
                                id)
                                    _bpftool_get_prog_ids
                                ;;
                                name)
                                    _bpftool_get_prog_names
                                ;;
                                pinned)
                                    _filedir
                                ;;
                            esac;
                            return 0
                        ;;
                        6)
                            COMPREPLY=($( compgen -W 'dev' -- "$cur" ));
                            return 0
                        ;;
                        8)
                            _bpftool_once_attr 'overwrite';
                            return 0
                        ;;
                    esac
                ;;
                detach)
                    case $cword in 
                        3)
                            COMPREPLY=($( compgen -W "$ATTACH_TYPES" -- "$cur" ));
                            return 0
                        ;;
                        4)
                            COMPREPLY=($( compgen -W 'dev' -- "$cur" ));
                            return 0
                        ;;
                    esac
                ;;
                *)
                    [[ $prev == $object ]] && COMPREPLY=($( compgen -W 'help \
                            show list attach detach' -- "$cur" ))
                ;;
            esac
        ;;
        feature)
            case $command in 
                probe)
                    [[ $prev == "prefix" ]] && return 0;
                    if _bpftool_search_list 'macros'; then
                        _bpftool_once_attr 'prefix';
                    else
                        COMPREPLY+=($( compgen -W 'macros' -- "$cur" ));
                    fi;
                    _bpftool_one_of_list 'kernel dev';
                    _bpftool_once_attr 'full unprivileged';
                    return 0
                ;;
                list_builtins)
                    [[ $prev != "$command" ]] && return 0;
                    COMPREPLY=($( compgen -W 'prog_types map_types \
                        attach_types link_types helpers' -- "$cur" ))
                ;;
                *)
                    [[ $prev == $object ]] && COMPREPLY=($( compgen -W 'help list_builtins probe' -- "$cur" ))
                ;;
            esac
        ;;
        link)
            case $command in 
                show | list | pin | detach)
                    case $prev in 
                        id)
                            _bpftool_get_link_ids;
                            return 0
                        ;;
                    esac
                ;;
            esac;
            local LINK_TYPE='id pinned';
            case $command in 
                show | list)
                    [[ $prev != "$command" ]] && return 0;
                    COMPREPLY=($( compgen -W "$LINK_TYPE" -- "$cur" ));
                    return 0
                ;;
                pin | detach)
                    if [[ $prev == "$command" ]]; then
                        COMPREPLY=($( compgen -W "$LINK_TYPE" -- "$cur" ));
                    else
                        _filedir;
                    fi;
                    return 0
                ;;
                *)
                    [[ $prev == $object ]] && COMPREPLY=($( compgen -W 'help pin show list' -- "$cur" ))
                ;;
            esac
        ;;
    esac
}
_bpftool_get_btf_ids () 
{ 
    COMPREPLY+=($( compgen -W "$( bpftool -jp btf 2>&1 |         command sed -n 's/.*"id": \(.*\),$/\1/p' )" -- "$cur" ))
}
_bpftool_get_link_ids () 
{ 
    COMPREPLY+=($( compgen -W "$( bpftool -jp link 2>&1 |         command sed -n 's/.*"id": \(.*\),$/\1/p' )" -- "$cur" ))
}
_bpftool_get_map_ids () 
{ 
    COMPREPLY+=($( compgen -W "$( bpftool -jp map  2>&1 |         command sed -n 's/.*"id": \(.*\),$/\1/p' )" -- "$cur" ))
}
_bpftool_get_map_ids_for_type () 
{ 
    local type="$1";
    COMPREPLY+=($( compgen -W "$( bpftool -jp map  2>&1 |         command grep -C2 "$type" |         command sed -n 's/.*"id": \(.*\),$/\1/p' )" -- "$cur" ))
}
_bpftool_get_map_names () 
{ 
    COMPREPLY+=($( compgen -W "$( bpftool -jp map  2>&1 |         command sed -n 's/.*"name": \(.*\),$/\1/p' )" -- "$cur" ))
}
_bpftool_get_map_names_for_type () 
{ 
    local type="$1";
    COMPREPLY+=($( compgen -W "$( bpftool -jp map  2>&1 |         command grep -C2 "$type" |         command sed -n 's/.*"name": \(.*\),$/\1/p' )" -- "$cur" ))
}
_bpftool_get_obj_map_idxs () 
{ 
    local obj;
    obj=$1;
    nmaps=$(objdump -j maps -t $obj 2>/dev/null | grep -c 'g     . maps');
    COMPREPLY+=($( compgen -W "$(seq 0 $((nmaps - 1)))" -- "$cur" ))
}
_bpftool_get_obj_map_names () 
{ 
    local obj;
    obj=$1;
    maps=$(objdump -j maps -t $obj 2>/dev/null |         command awk '/g     . maps/ {print $NF}');
    COMPREPLY+=($( compgen -W "$maps" -- "$cur" ))
}
_bpftool_get_prog_ids () 
{ 
    COMPREPLY+=($( compgen -W "$( bpftool -jp prog 2>&1 |         command sed -n 's/.*"id": \(.*\),$/\1/p' )" -- "$cur" ))
}
_bpftool_get_prog_names () 
{ 
    COMPREPLY+=($( compgen -W "$( bpftool -jp prog 2>&1 |         command sed -n 's/.*"name": "\(.*\)",$/\1/p' )" -- "$cur" ))
}
_bpftool_get_prog_tags () 
{ 
    COMPREPLY+=($( compgen -W "$( bpftool -jp prog 2>&1 |         command sed -n 's/.*"tag": "\(.*\)",$/\1/p' )" -- "$cur" ))
}
_bpftool_map_guess_map_type () 
{ 
    local keyword ref;
    for ((idx=3; idx < ${#words[@]}-1; idx++ ))
    do
        case "${words[$((idx-2))]}" in 
            lookup | update)
                keyword=${words[$((idx-1))]};
                ref=${words[$((idx))]}
            ;;
            push)
                printf "stack";
                return 0
            ;;
            enqueue)
                printf "queue";
                return 0
            ;;
        esac;
    done;
    [[ -z $ref ]] && return 0;
    local type;
    type=$(bpftool -jp map show $keyword $ref |         command sed -n 's/.*"type": "\(.*\)",$/\1/p');
    [[ -n $type ]] && printf $type
}
_bpftool_map_update_get_id () 
{ 
    local command="$1";
    local idx value;
    for ((idx=7; idx < ${#words[@]}-1; idx++ ))
    do
        if [[ ${words[idx]} == "value" ]]; then
            value=1;
            break;
        fi;
    done;
    if [[ $value -eq 0 ]]; then
        case "$command" in 
            push)
                _bpftool_get_map_ids_for_type stack
            ;;
            enqueue)
                _bpftool_get_map_ids_for_type queue
            ;;
            *)
                _bpftool_get_map_ids
            ;;
        esac;
        return 0;
    fi;
    local type=$(_bpftool_map_guess_map_type);
    case $type in 
        array_of_maps | hash_of_maps)
            _bpftool_get_map_ids;
            return 0
        ;;
        prog_array)
            _bpftool_get_prog_ids;
            return 0
        ;;
        *)
            return 0
        ;;
    esac
}
_bpftool_map_update_get_name () 
{ 
    local command="$1";
    local idx value;
    for ((idx=7; idx < ${#words[@]}-1; idx++ ))
    do
        if [[ ${words[idx]} == "value" ]]; then
            value=1;
            break;
        fi;
    done;
    if [[ $value -eq 0 ]]; then
        case "$command" in 
            push)
                _bpftool_get_map_names_for_type stack
            ;;
            enqueue)
                _bpftool_get_map_names_for_type queue
            ;;
            *)
                _bpftool_get_map_names
            ;;
        esac;
        return 0;
    fi;
    local type=$(_bpftool_map_guess_map_type);
    case $type in 
        array_of_maps | hash_of_maps)
            _bpftool_get_map_names;
            return 0
        ;;
        prog_array)
            _bpftool_get_prog_names;
            return 0
        ;;
        *)
            return 0
        ;;
    esac
}
_bpftool_once_attr () 
{ 
    local w idx found;
    for w in $*;
    do
        found=0;
        for ((idx=3; idx < ${#words[@]}-1; idx++ ))
        do
            if [[ $w == ${words[idx]} ]]; then
                found=1;
                break;
            fi;
        done;
        [[ $found -eq 0 ]] && COMPREPLY+=($( compgen -W "$w" -- "$cur" ));
    done
}
_bpftool_one_of_list () 
{ 
    _bpftool_search_list $* && return 1;
    COMPREPLY+=($( compgen -W "$*" -- "$cur" ))
}
_bpftool_search_list () 
{ 
    local w idx;
    for w in $*;
    do
        for ((idx=3; idx < ${#words[@]}-1; idx++ ))
        do
            [[ $w == ${words[idx]} ]] && return 0;
        done;
    done;
    return 1
}
_cd () 
{ 
    local cur prev words cword;
    _init_completion || return;
    local IFS='
' i j k;
    compopt -o filenames;
    if [[ -z ${CDPATH:-} || $cur == ?(.)?(.)/* ]]; then
        _filedir -d;
        return;
    fi;
    local -r mark_dirs=$(_rl_enabled mark-directories && echo y);
    local -r mark_symdirs=$(_rl_enabled mark-symlinked-directories && echo y);
    for i in ${CDPATH//:/'
'};
    do
        k="${#COMPREPLY[@]}";
        for j in $(compgen -d -- $i/$cur);
        do
            if [[ ( -n $mark_symdirs && -L $j || -n $mark_dirs && ! -L $j ) && ! -d ${j#$i/} ]]; then
                j+="/";
            fi;
            COMPREPLY[k++]=${j#$i/};
        done;
    done;
    _filedir -d;
    if ((${#COMPREPLY[@]} == 1)); then
        i=${COMPREPLY[0]};
        if [[ $i == "$cur" && $i != "*/" ]]; then
            COMPREPLY[0]="${i}/";
        fi;
    fi;
    return
}
_cd_devices () 
{ 
    COMPREPLY+=($(compgen -f -d -X "!*/?([amrs])cd*" -- "${cur:-/dev/}"))
}
_chgrp () 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    cur=${cur//\\\\/};
    if [[ $prev == --reference ]]; then
        _filedir;
        return;
    fi;
    $split && return;
    if [[ $cur == -* ]]; then
        local w opts;
        for w in "${words[@]}";
        do
            [[ $w == -@(R|-recursive) ]] && opts="-H -L -P" && break;
        done;
        COMPREPLY=($(compgen -W '-c -h -f -R -v --changes --dereference
            --no-dereference --silent --quiet --reference --recursive --verbose
            --help --version $opts' -- "$cur"));
        return;
    fi;
    if [[ $cword -eq 1 && $cur != -* || $prev == -* ]]; then
        _allowed_groups "$cur";
    else
        _filedir;
    fi
}
_command () 
{ 
    local offset i;
    offset=1;
    for ((i = 1; i <= COMP_CWORD; i++))
    do
        if [[ ${COMP_WORDS[i]} != -* ]]; then
            offset=$i;
            break;
        fi;
    done;
    _command_offset $offset
}
_command_offset () 
{ 
    local word_offset=$1 i j;
    for ((i = 0; i < word_offset; i++))
    do
        for ((j = 0; j <= ${#COMP_LINE}; j++))
        do
            [[ $COMP_LINE == "${COMP_WORDS[i]}"* ]] && break;
            COMP_LINE=${COMP_LINE:1};
            ((COMP_POINT--));
        done;
        COMP_LINE=${COMP_LINE#"${COMP_WORDS[i]}"};
        ((COMP_POINT -= ${#COMP_WORDS[i]}));
    done;
    for ((i = 0; i <= COMP_CWORD - word_offset; i++))
    do
        COMP_WORDS[i]=${COMP_WORDS[i + word_offset]};
    done;
    for ((i; i <= COMP_CWORD; i++))
    do
        unset 'COMP_WORDS[i]';
    done;
    ((COMP_CWORD -= word_offset));
    COMPREPLY=();
    local cur;
    _get_comp_words_by_ref cur;
    if ((COMP_CWORD == 0)); then
        local IFS='
';
        compopt -o filenames;
        COMPREPLY=($(compgen -d -c -- "$cur"));
    else
        local cmd=${COMP_WORDS[0]} compcmd=${COMP_WORDS[0]};
        local cspec=$(complete -p $cmd 2>/dev/null);
        if [[ ! -n $cspec && $cmd == */* ]]; then
            cspec=$(complete -p ${cmd##*/} 2>/dev/null);
            [[ -n $cspec ]] && compcmd=${cmd##*/};
        fi;
        if [[ ! -n $cspec ]]; then
            compcmd=${cmd##*/};
            _completion_loader $compcmd;
            cspec=$(complete -p $compcmd 2>/dev/null);
        fi;
        if [[ -n $cspec ]]; then
            if [[ ${cspec#* -F } != "$cspec" ]]; then
                local func=${cspec#*-F };
                func=${func%% *};
                if ((${#COMP_WORDS[@]} >= 2)); then
                    $func $cmd "${COMP_WORDS[-1]}" "${COMP_WORDS[-2]}";
                else
                    $func $cmd "${COMP_WORDS[-1]}";
                fi;
                local opt;
                while [[ $cspec == *" -o "* ]]; do
                    cspec=${cspec#*-o };
                    opt=${cspec%% *};
                    compopt -o $opt;
                    cspec=${cspec#$opt};
                done;
            else
                cspec=${cspec#complete};
                cspec=${cspec%%$compcmd};
                COMPREPLY=($(eval compgen "$cspec" -- '$cur'));
            fi;
        else
            if ((${#COMPREPLY[@]} == 0)); then
                _minimal;
            fi;
        fi;
    fi
}
_comp_iprconfig () 
{ 
    iprconfig="${COMP_WORDS[0]}";
    cur="${COMP_WORDS[COMP_CWORD]}";
    prev="${COMP_WORDS[COMP_CWORD-1]}";
    case "${prev}" in 
        "-c")
            opts=$(${iprconfig} -l 2>/dev/null);
            COMPREPLY=($(compgen -W "${opts}" -- ${cur}))
        ;;
        "-k")
            COMPREPLY=($(compgen -o dirnames -- ${cur}))
        ;;
        *)
            opts=$(find /dev -printf "%f\n" | grep -G "^\(sd\|sg\)");
            COMPREPLY=($(compgen -W "${opts}" -- ${cur}))
        ;;
    esac;
    return 0
}
_complete_as_root () 
{ 
    [[ $EUID -eq 0 || -n ${root_command:-} ]]
}
_completion_loader () 
{ 
    local cmd="${1:-_EmptycmD_}";
    __load_completion "$cmd" && return 124;
    complete -F _minimal -- "$cmd" && return 124
}
_configured_interfaces () 
{ 
    if [[ -f /etc/debian_version ]]; then
        COMPREPLY=($(compgen -W "$(command sed -ne 's|^iface \([^ ]\{1,\}\).*$|\1|p'             /etc/network/interfaces /etc/network/interfaces.d/* 2>/dev/null)"             -- "$cur"));
    else
        if [[ -f /etc/SuSE-release ]]; then
            COMPREPLY=($(compgen -W "$(printf '%s\n'             /etc/sysconfig/network/ifcfg-* |
            command sed -ne 's|.*ifcfg-\([^*].*\)$|\1|p')" -- "$cur"));
        else
            if [[ -f /etc/pld-release ]]; then
                COMPREPLY=($(compgen -W "$(command ls -B             /etc/sysconfig/interfaces |
            command sed -ne 's|.*ifcfg-\([^*].*\)$|\1|p')" -- "$cur"));
            else
                COMPREPLY=($(compgen -W "$(printf '%s\n'             /etc/sysconfig/network-scripts/ifcfg-* |
            command sed -ne 's|.*ifcfg-\([^*].*\)$|\1|p')" -- "$cur"));
            fi;
        fi;
    fi
}
_count_args () 
{ 
    local i cword words;
    __reassemble_comp_words_by_ref "${1-}" words cword;
    args=1;
    for ((i = 1; i < cword; i++))
    do
        if [[ ${words[i]} != -* && ${words[i - 1]} != ${2-} || ${words[i]} == ${3-} ]]; then
            ((args++));
        fi;
    done
}
_cvmfs_config () 
{ 
    local cur prev opts;
    COMPREPLY=();
    cur="${COMP_WORDS[COMP_CWORD]}";
    prev="${COMP_WORDS[COMP_CWORD-1]}";
    local -r cmds="setup chksetup showconfig stat status probe reload umount bugreport";
    case "${prev}" in 
        setup)
            COMPREPLY=($(compgen -W "nouser nocfgmod" ${cur}));
            return 0
        ;;
        showconfig)
            COMPREPLY=($(compgen -W "$(__local_repos)" ${cur}));
            return 0
        ;;
        stat)
            case "${cur}" in 
                -*)
                    COMPREPLY=($(compgen -W "-v" ${cur}));
                    return 0
                ;;
                *)
                    COMPREPLY=($(compgen -W "$(__local_repos)" ${cur} ));
                    return 0
                ;;
            esac
        ;;
        reload)
            case "${cur}" in 
                -*)
                    COMPREPLY=($(compgen -W "-c" ${cur}));
                    return 0
                ;;
                *)
                    COMPREPLY=($(compgen -W "$(__local_repos)" ${cur}));
                    return 0
                ;;
            esac
        ;;
    esac;
    COMPREPLY=($(compgen -W "${cmds}" -- ${cur}));
    return 0
}
_cvmfs_server () 
{ 
    local cur cmd;
    COMPREPLY=();
    cur="${COMP_WORDS[COMP_CWORD]}";
    prev_idx=$(( $COMP_CWORD - 1));
    prev="${COMP_WORDS[$prev_idx]}";
    cmd="${COMP_WORDS[1]}";
    local -r cmds="mkfs add-replica import publish rollback rmfs     resign list info tag check transaction abort snapshot migrate     list-catalogs update-info update-repoinfo mount";
    if [ $COMP_CWORD -le 1 ]; then
        COMPREPLY=($(compgen -W "${cmds}" -- ${cur}));
        return 0;
    fi;
    case "${cmd}" in 
        publish)
            COMPREPLY=($(compgen -W "$(__hosted_repos '/stratum0/ && /transaction/')" ${cur}));
            return 0
        ;;
        abort)
            COMPREPLY=($(compgen -W "$(__hosted_repos '/stratum0/ && /transaction/')" ${cur}));
            return 0
        ;;
        rollback)
            COMPREPLY=($(compgen -W "$(__hosted_repos '/stratum0/')" ${cur}));
            return 0
        ;;
        resign)
            COMPREPLY=($(compgen -W "$(__hosted_repos '/stratum0/')" ${cur}));
            return 0
        ;;
        tag)
            case "$prev" in 
                -a | -r | -i)
                    COMPREPLY=($(compgen -W "$(__tags)" ${cur}))
                ;;
                *)
                    COMPREPLY=($(compgen -W "$(__hosted_repos '/stratum0/')" ${cur}));
                    return 0
                ;;
            esac
        ;;
        transaction)
            COMPREPLY=($(compgen -W "$(__hosted_repos '/stratum0/ && !/transaction/')" ${cur}));
            return 0
        ;;
        migrate)
            COMPREPLY=($(compgen -W "$(__hosted_repos '/INCOMPATIBLE/')" ${cur}));
            return 0
        ;;
        snapshot)
            COMPREPLY=($(compgen -W "$(__hosted_repos '/stratum1/')" ${cur}));
            return 0
        ;;
        rmfs)
            COMPREPLY=($(compgen -W "$(__hosted_repos)" ${cur}));
            return 0
        ;;
        alterfs)
            COMPREPLY=($(compgen -W "$(__hosted_repos)" ${cur}));
            return 0
        ;;
        info)
            COMPREPLY=($(compgen -W "$(__hosted_repos)" ${cur}));
            return 0
        ;;
        list-catalogs)
            COMPREPLY=($(compgen -W "$(__hosted_repos)" ${cur}));
            return 0
        ;;
        check)
            COMPREPLY=($(compgen -W "$(__hosted_repos)" ${cur}));
            return 0
        ;;
        gc)
            COMPREPLY=($(compgen -W "$(__hosted_repos)" ${cur}));
            return 0
        ;;
        update-repoinfo)
            COMPREPLY=($(compgen -W "$(__hosted_repos '/stratum0/')" ${cur}));
            return 0
        ;;
        mount)
            COMPREPLY=($(compgen -W "$(__hosted_repos '/stratum0/')" ${cur}));
            return 0
        ;;
    esac
}
_dvd_devices () 
{ 
    COMPREPLY+=($(compgen -f -d -X "!*/?(r)dvd*" -- "${cur:-/dev/}"))
}
_expand () 
{ 
    case ${cur-} in 
        ~*/*)
            __expand_tilde_by_ref cur
        ;;
        ~*)
            _tilde "$cur" || eval COMPREPLY[0]="$(printf ~%q "${COMPREPLY[0]#\~}")";
            return ${#COMPREPLY[@]}
        ;;
    esac
}
_filedir () 
{ 
    local IFS='
';
    _tilde "${cur-}" || return;
    local -a toks;
    local reset arg=${1-};
    if [[ $arg == -d ]]; then
        reset=$(shopt -po noglob);
        set -o noglob;
        toks=($(compgen -d -- "${cur-}"));
        IFS=' ';
        $reset;
        IFS='
';
    else
        local quoted;
        _quote_readline_by_ref "${cur-}" quoted;
        local xspec=${arg:+"!*.@($arg|${arg^^})"} plusdirs=();
        local opts=(-f -X "$xspec");
        [[ -n $xspec ]] && plusdirs=(-o plusdirs);
        [[ -n ${COMP_FILEDIR_FALLBACK-} || -z ${plusdirs-} ]] || opts+=("${plusdirs[@]}");
        reset=$(shopt -po noglob);
        set -o noglob;
        toks+=($(compgen "${opts[@]}" -- $quoted));
        IFS=' ';
        $reset;
        IFS='
';
        [[ -n ${COMP_FILEDIR_FALLBACK-} && -n $arg && ${#toks[@]} -lt 1 ]] && { 
            reset=$(shopt -po noglob);
            set -o noglob;
            toks+=($(compgen -f ${plusdirs+"${plusdirs[@]}"} -- $quoted));
            IFS=' ';
            $reset;
            IFS='
'
        };
    fi;
    if ((${#toks[@]} != 0)); then
        compopt -o filenames 2> /dev/null;
        COMPREPLY+=("${toks[@]}");
    fi
}
_filedir_xspec () 
{ 
    local cur prev words cword;
    _init_completion || return;
    _tilde "$cur" || return;
    local IFS='
' xspec=${_xspecs[${1##*/}]} tmp;
    local -a toks;
    toks=($(
        compgen -d -- "$(quote_readline "$cur")" | {
            while read -r tmp; do
                printf '%s\n' $tmp
            done
        }
    ));
    eval xspec="${xspec}";
    local matchop=!;
    if [[ $xspec == !* ]]; then
        xspec=${xspec#!};
        matchop=@;
    fi;
    xspec="$matchop($xspec|${xspec^^})";
    toks+=($(
        eval compgen -f -X "'!$xspec'" -- '$(quote_readline "$cur")' | {
            while read -r tmp; do
                [[ -n $tmp ]] && printf '%s\n' $tmp
            done
        }
    ));
    [[ -n ${COMP_FILEDIR_FALLBACK:-} && ${#toks[@]} -lt 1 ]] && { 
        local reset=$(shopt -po noglob);
        set -o noglob;
        toks+=($(compgen -f -- "$(quote_readline "$cur")"));
        IFS=' ';
        $reset;
        IFS='
'
    };
    if ((${#toks[@]} != 0)); then
        compopt -o filenames;
        COMPREPLY=("${toks[@]}");
    fi
}
_fstypes () 
{ 
    local fss;
    if [[ -e /proc/filesystems ]]; then
        fss="$(cut -d'	' -f2 /proc/filesystems)
             $(awk '! /\*/ { print $NF }' /etc/filesystems 2>/dev/null)";
    else
        fss="$(awk '/^[ \t]*[^#]/ { print $3 }' /etc/fstab 2>/dev/null)
             $(awk '/^[ \t]*[^#]/ { print $3 }' /etc/mnttab 2>/dev/null)
             $(awk '/^[ \t]*[^#]/ { print $4 }' /etc/vfstab 2>/dev/null)
             $(awk '{ print $1 }' /etc/dfs/fstypes 2>/dev/null)
             $([[ -d /etc/fs ]] && command ls /etc/fs)";
    fi;
    [[ -n $fss ]] && COMPREPLY+=($(compgen -W "$fss" -- "$cur"))
}
_get_comp_words_by_ref () 
{ 
    local exclude flag i OPTIND=1;
    local cur cword words=();
    local upargs=() upvars=() vcur vcword vprev vwords;
    while getopts "c:i:n:p:w:" flag "$@"; do
        case $flag in 
            c)
                vcur=$OPTARG
            ;;
            i)
                vcword=$OPTARG
            ;;
            n)
                exclude=$OPTARG
            ;;
            p)
                vprev=$OPTARG
            ;;
            w)
                vwords=$OPTARG
            ;;
            *)
                echo "bash_completion: $FUNCNAME: usage error" 1>&2;
                return 1
            ;;
        esac;
    done;
    while [[ $# -ge $OPTIND ]]; do
        case ${!OPTIND} in 
            cur)
                vcur=cur
            ;;
            prev)
                vprev=prev
            ;;
            cword)
                vcword=cword
            ;;
            words)
                vwords=words
            ;;
            *)
                echo "bash_completion: $FUNCNAME: \`${!OPTIND}':" "unknown argument" 1>&2;
                return 1
            ;;
        esac;
        ((OPTIND += 1));
    done;
    __get_cword_at_cursor_by_ref "${exclude-}" words cword cur;
    [[ -v vcur ]] && { 
        upvars+=("$vcur");
        upargs+=(-v $vcur "$cur")
    };
    [[ -v vcword ]] && { 
        upvars+=("$vcword");
        upargs+=(-v $vcword "$cword")
    };
    [[ -v vprev && $cword -ge 1 ]] && { 
        upvars+=("$vprev");
        upargs+=(-v $vprev "${words[cword - 1]}")
    };
    [[ -v vwords ]] && { 
        upvars+=("$vwords");
        upargs+=(-a${#words[@]} $vwords ${words+"${words[@]}"})
    };
    ((${#upvars[@]})) && local "${upvars[@]}" && _upvars "${upargs[@]}"
}
_get_cword () 
{ 
    local LC_CTYPE=C;
    local cword words;
    __reassemble_comp_words_by_ref "${1-}" words cword;
    if [[ -n ${2-} && -n ${2//[^0-9]/} ]]; then
        printf "%s" "${words[cword - $2]}";
    else
        if ((${#words[cword]} == 0 && COMP_POINT == ${#COMP_LINE})); then
            :;
        else
            local i;
            local cur="$COMP_LINE";
            local index="$COMP_POINT";
            for ((i = 0; i <= cword; ++i))
            do
                while [[ ${#cur} -ge ${#words[i]} && ${cur:0:${#words[i]}} != "${words[i]}" ]]; do
                    cur="${cur:1}";
                    ((index > 0)) && ((index--));
                done;
                if ((i < cword)); then
                    local old_size="${#cur}";
                    cur="${cur#${words[i]}}";
                    local new_size="${#cur}";
                    ((index -= old_size - new_size));
                fi;
            done;
            if [[ ${words[cword]:0:${#cur}} != "$cur" ]]; then
                printf "%s" "${words[cword]}";
            else
                printf "%s" "${cur:0:index}";
            fi;
        fi;
    fi
}
_get_first_arg () 
{ 
    local i;
    arg=;
    for ((i = 1; i < COMP_CWORD; i++))
    do
        if [[ ${COMP_WORDS[i]} != -* ]]; then
            arg=${COMP_WORDS[i]};
            break;
        fi;
    done
}
_get_pword () 
{ 
    if ((COMP_CWORD >= 1)); then
        _get_cword "${@:-}" 1;
    fi
}
_gids () 
{ 
    if type getent &> /dev/null; then
        COMPREPLY=($(compgen -W '$(getent group | cut -d: -f3)' -- "$cur"));
    else
        if type perl &> /dev/null; then
            COMPREPLY=($(compgen -W '$(perl -e '"'"'while (($gid) = (getgrent)[2]) { print $gid . "\n" }'"'"')' -- "$cur"));
        else
            COMPREPLY=($(compgen -W '$(cut -d: -f3 /etc/group)' -- "$cur"));
        fi;
    fi
}
_git_add () 
{ 
    case "$cur" in 
        --chmod=*)
            __gitcomp "+x -x" "" "${cur##--chmod=}";
            return
        ;;
        --*)
            __gitcomp_builtin add;
            return
        ;;
    esac;
    local complete_opt="--others --modified --directory --no-empty-directory";
    if test -n "$(__git_find_on_cmdline "-u --update")"; then
        complete_opt="--modified";
    fi;
    __git_complete_index_file "$complete_opt"
}
_git_am () 
{ 
    __git_find_repo_path;
    if [ -d "$__git_repo_path"/rebase-apply ]; then
        __gitcomp "$__git_am_inprogress_options";
        return;
    fi;
    case "$cur" in 
        --whitespace=*)
            __gitcomp "$__git_whitespacelist" "" "${cur##--whitespace=}";
            return
        ;;
        --patch-format=*)
            __gitcomp "$__git_patchformat" "" "${cur##--patch-format=}";
            return
        ;;
        --show-current-patch=*)
            __gitcomp "$__git_showcurrentpatch" "" "${cur##--show-current-patch=}";
            return
        ;;
        --quoted-cr=*)
            __gitcomp "$__git_quoted_cr" "" "${cur##--quoted-cr=}";
            return
        ;;
        --*)
            __gitcomp_builtin am "" "$__git_am_inprogress_options";
            return
        ;;
    esac
}
_git_apply () 
{ 
    case "$cur" in 
        --whitespace=*)
            __gitcomp "$__git_whitespacelist" "" "${cur##--whitespace=}";
            return
        ;;
        --*)
            __gitcomp_builtin apply;
            return
        ;;
    esac
}
_git_archive () 
{ 
    case "$cur" in 
        --format=*)
            __gitcomp "$(git archive --list)" "" "${cur##--format=}";
            return
        ;;
        --remote=*)
            __gitcomp_nl "$(__git_remotes)" "" "${cur##--remote=}";
            return
        ;;
        --*)
            __gitcomp_builtin archive "--format= --list --verbose --prefix= --worktree-attributes";
            return
        ;;
    esac;
    __git_complete_file
}
_git_bisect () 
{ 
    __git_has_doubledash && return;
    local subcommands="start bad good skip reset visualize replay log run";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        __git_find_repo_path;
        if [ -f "$__git_repo_path"/BISECT_START ]; then
            __gitcomp "$subcommands";
        else
            __gitcomp "replay start";
        fi;
        return;
    fi;
    case "$subcommand" in 
        bad | good | reset | skip | start)
            __git_complete_refs
        ;;
        *)

        ;;
    esac
}
_git_branch () 
{ 
    local i c="$__git_cmd_idx" only_local_ref="n" has_r="n";
    while [ $c -lt $cword ]; do
        i="${words[c]}";
        case "$i" in 
            -d | -D | --delete | -m | -M | --move | -c | -C | --copy)
                only_local_ref="y"
            ;;
            -r | --remotes)
                has_r="y"
            ;;
        esac;
        ((c++));
    done;
    case "$cur" in 
        --set-upstream-to=*)
            __git_complete_refs --cur="${cur##--set-upstream-to=}"
        ;;
        --*)
            __gitcomp_builtin branch
        ;;
        *)
            if [ $only_local_ref = "y" -a $has_r = "n" ]; then
                __gitcomp_direct "$(__git_heads "" "$cur" " ")";
            else
                __git_complete_refs;
            fi
        ;;
    esac
}
_git_bundle () 
{ 
    local cmd="${words[__git_cmd_idx+1]}";
    case "$cword" in 
        $((__git_cmd_idx+1)))
            __gitcomp "create list-heads verify unbundle"
        ;;
        $((__git_cmd_idx+2)))

        ;;
        *)
            case "$cmd" in 
                create)
                    __git_complete_revlist
                ;;
            esac
        ;;
    esac
}
_git_checkout () 
{ 
    __git_has_doubledash && return;
    local dwim_opt="$(__git_checkout_default_dwim_mode)";
    case "$prev" in 
        -b | -B | --orphan)
            __git_complete_refs $dwim_opt --mode="heads";
            return
        ;;
        *)

        ;;
    esac;
    case "$cur" in 
        --conflict=*)
            __gitcomp "diff3 merge zdiff3" "" "${cur##--conflict=}"
        ;;
        --*)
            __gitcomp_builtin checkout
        ;;
        *)
            if [ -n "$(__git_find_on_cmdline "-b -B -d --detach --orphan")" ]; then
                __git_complete_refs --mode="refs";
            else
                if [ -n "$(__git_find_on_cmdline "-t --track")" ]; then
                    __git_complete_refs --mode="remote-heads";
                else
                    __git_complete_refs $dwim_opt --mode="refs";
                fi;
            fi
        ;;
    esac
}
_git_cherry_pick () 
{ 
    __git_find_repo_path;
    if __git_pseudoref_exists CHERRY_PICK_HEAD; then
        __gitcomp "$__git_cherry_pick_inprogress_options";
        return;
    fi;
    __git_complete_strategy && return;
    case "$cur" in 
        --*)
            __gitcomp_builtin cherry-pick "" "$__git_cherry_pick_inprogress_options"
        ;;
        *)
            __git_complete_refs
        ;;
    esac
}
_git_clean () 
{ 
    case "$cur" in 
        --*)
            __gitcomp_builtin clean;
            return
        ;;
    esac;
    __git_complete_index_file "--others --directory"
}
_git_clone () 
{ 
    case "$prev" in 
        -c | --config)
            __git_complete_config_variable_name_and_value;
            return
        ;;
    esac;
    case "$cur" in 
        --config=*)
            __git_complete_config_variable_name_and_value --cur="${cur##--config=}";
            return
        ;;
        --*)
            __gitcomp_builtin clone;
            return
        ;;
    esac
}
_git_commit () 
{ 
    case "$prev" in 
        -c | -C)
            __git_complete_refs;
            return
        ;;
    esac;
    case "$cur" in 
        --cleanup=*)
            __gitcomp "default scissors strip verbatim whitespace
			" "" "${cur##--cleanup=}";
            return
        ;;
        --reuse-message=* | --reedit-message=* | --fixup=* | --squash=*)
            __git_complete_refs --cur="${cur#*=}";
            return
        ;;
        --untracked-files=*)
            __gitcomp "$__git_untracked_file_modes" "" "${cur##--untracked-files=}";
            return
        ;;
        --trailer=*)
            __gitcomp_nl "$(__git_trailer_tokens)" "" "${cur##--trailer=}" ":";
            return
        ;;
        --*)
            __gitcomp_builtin commit;
            return
        ;;
    esac;
    if __git rev-parse --verify --quiet HEAD > /dev/null; then
        __git_complete_index_file "--committable";
    else
        __git_complete_index_file "--cached";
    fi
}
_git_config () 
{ 
    case "$prev" in 
        --get | --get-all | --unset | --unset-all)
            __gitcomp_nl "$(__git_config_get_set_variables)";
            return
        ;;
        *.*)
            __git_complete_config_variable_value;
            return
        ;;
    esac;
    case "$cur" in 
        --*)
            __gitcomp_builtin config
        ;;
        *)
            __git_complete_config_variable_name
        ;;
    esac
}
_git_describe () 
{ 
    case "$cur" in 
        --*)
            __gitcomp_builtin describe;
            return
        ;;
    esac;
    __git_complete_refs
}
_git_diff () 
{ 
    __git_has_doubledash && return;
    case "$cur" in 
        --diff-algorithm=*)
            __gitcomp "$__git_diff_algorithms" "" "${cur##--diff-algorithm=}";
            return
        ;;
        --submodule=*)
            __gitcomp "$__git_diff_submodule_formats" "" "${cur##--submodule=}";
            return
        ;;
        --color-moved=*)
            __gitcomp "$__git_color_moved_opts" "" "${cur##--color-moved=}";
            return
        ;;
        --color-moved-ws=*)
            __gitcomp "$__git_color_moved_ws_opts" "" "${cur##--color-moved-ws=}";
            return
        ;;
        --ws-error-highlight=*)
            __gitcomp "$__git_ws_error_highlight_opts" "" "${cur##--ws-error-highlight=}";
            return
        ;;
        --*)
            __gitcomp "$__git_diff_difftool_options";
            return
        ;;
    esac;
    __git_complete_revlist_file
}
_git_difftool () 
{ 
    __git_has_doubledash && return;
    case "$cur" in 
        --tool=*)
            __gitcomp "$__git_mergetools_common kompare" "" "${cur##--tool=}";
            return
        ;;
        --*)
            __gitcomp_builtin difftool "$__git_diff_difftool_options";
            return
        ;;
    esac;
    __git_complete_revlist_file
}
_git_fetch () 
{ 
    case "$cur" in 
        --recurse-submodules=*)
            __gitcomp "$__git_fetch_recurse_submodules" "" "${cur##--recurse-submodules=}";
            return
        ;;
        --filter=*)
            __gitcomp "blob:none blob:limit= sparse:oid=" "" "${cur##--filter=}";
            return
        ;;
        --*)
            __gitcomp_builtin fetch;
            return
        ;;
    esac;
    __git_complete_remote_or_refspec
}
_git_format_patch () 
{ 
    case "$cur" in 
        --thread=*)
            __gitcomp "
			deep shallow
			" "" "${cur##--thread=}";
            return
        ;;
        --base=* | --interdiff=* | --range-diff=*)
            __git_complete_refs --cur="${cur#--*=}";
            return
        ;;
        --*)
            __gitcomp_builtin format-patch "$__git_format_patch_extra_options";
            return
        ;;
    esac;
    __git_complete_revlist
}
_git_fsck () 
{ 
    case "$cur" in 
        --*)
            __gitcomp_builtin fsck;
            return
        ;;
    esac
}
_git_gitk () 
{ 
    __gitk_main
}
_git_grep () 
{ 
    __git_has_doubledash && return;
    case "$cur" in 
        --*)
            __gitcomp_builtin grep;
            return
        ;;
    esac;
    case "$cword,$prev" in 
        $((__git_cmd_idx+1)),* | *,-*)
            __git_complete_symbol && return
        ;;
    esac;
    __git_complete_refs
}
_git_help () 
{ 
    case "$cur" in 
        --*)
            __gitcomp_builtin help;
            return
        ;;
    esac;
    if test -n "${GIT_TESTING_ALL_COMMAND_LIST-}"; then
        __gitcomp "$GIT_TESTING_ALL_COMMAND_LIST $(__git --list-cmds=alias,list-guide) gitk";
    else
        __gitcomp "$(__git --list-cmds=main,nohelpers,alias,list-guide) gitk";
    fi
}
_git_init () 
{ 
    case "$cur" in 
        --shared=*)
            __gitcomp "
			false true umask group all world everybody
			" "" "${cur##--shared=}";
            return
        ;;
        --*)
            __gitcomp_builtin init;
            return
        ;;
    esac
}
_git_log () 
{ 
    __git_has_doubledash && return;
    __git_find_repo_path;
    local merge="";
    if __git_pseudoref_exists MERGE_HEAD; then
        merge="--merge";
    fi;
    case "$prev,$cur" in 
        -L,:*:*)
            return
        ;;
        -L,:*)
            __git_complete_symbol --cur="${cur#:}" --sfx=":";
            return
        ;;
        -G,* | -S,*)
            __git_complete_symbol;
            return
        ;;
    esac;
    case "$cur" in 
        --pretty=* | --format=*)
            __gitcomp "$__git_log_pretty_formats $(__git_pretty_aliases)
			" "" "${cur#*=}";
            return
        ;;
        --date=*)
            __gitcomp "$__git_log_date_formats" "" "${cur##--date=}";
            return
        ;;
        --decorate=*)
            __gitcomp "full short no" "" "${cur##--decorate=}";
            return
        ;;
        --diff-algorithm=*)
            __gitcomp "$__git_diff_algorithms" "" "${cur##--diff-algorithm=}";
            return
        ;;
        --submodule=*)
            __gitcomp "$__git_diff_submodule_formats" "" "${cur##--submodule=}";
            return
        ;;
        --ws-error-highlight=*)
            __gitcomp "$__git_ws_error_highlight_opts" "" "${cur##--ws-error-highlight=}";
            return
        ;;
        --no-walk=*)
            __gitcomp "sorted unsorted" "" "${cur##--no-walk=}";
            return
        ;;
        --diff-merges=*)
            __gitcomp "$__git_diff_merges_opts" "" "${cur##--diff-merges=}";
            return
        ;;
        --*)
            __gitcomp "
			$__git_log_common_options
			$__git_log_shortlog_options
			$__git_log_gitk_options
			$__git_log_show_options
			--root --topo-order --date-order --reverse
			--follow --full-diff
			--abbrev-commit --no-abbrev-commit --abbrev=
			--relative-date --date=
			--pretty= --format= --oneline
			--show-signature
			--cherry-mark
			--cherry-pick
			--graph
			--decorate --decorate= --no-decorate
			--walk-reflogs
			--no-walk --no-walk= --do-walk
			--parents --children
			--expand-tabs --expand-tabs= --no-expand-tabs
			$merge
			$__git_diff_common_options
			";
            return
        ;;
        -L:*:*)
            return
        ;;
        -L:*)
            __git_complete_symbol --cur="${cur#-L:}" --sfx=":";
            return
        ;;
        -G*)
            __git_complete_symbol --pfx="-G" --cur="${cur#-G}";
            return
        ;;
        -S*)
            __git_complete_symbol --pfx="-S" --cur="${cur#-S}";
            return
        ;;
    esac;
    __git_complete_revlist
}
_git_ls_files () 
{ 
    case "$cur" in 
        --*)
            __gitcomp_builtin ls-files;
            return
        ;;
    esac;
    __git_complete_index_file "--cached"
}
_git_ls_remote () 
{ 
    case "$cur" in 
        --*)
            __gitcomp_builtin ls-remote;
            return
        ;;
    esac;
    __gitcomp_nl "$(__git_remotes)"
}
_git_ls_tree () 
{ 
    case "$cur" in 
        --*)
            __gitcomp_builtin ls-tree;
            return
        ;;
    esac;
    __git_complete_file
}
_git_merge () 
{ 
    __git_complete_strategy && return;
    case "$cur" in 
        --*)
            __gitcomp_builtin merge;
            return
        ;;
    esac;
    __git_complete_refs
}
_git_merge_base () 
{ 
    case "$cur" in 
        --*)
            __gitcomp_builtin merge-base;
            return
        ;;
    esac;
    __git_complete_refs
}
_git_mergetool () 
{ 
    case "$cur" in 
        --tool=*)
            __gitcomp "$__git_mergetools_common tortoisemerge" "" "${cur##--tool=}";
            return
        ;;
        --*)
            __gitcomp "--tool= --prompt --no-prompt --gui --no-gui";
            return
        ;;
    esac
}
_git_mv () 
{ 
    case "$cur" in 
        --*)
            __gitcomp_builtin mv;
            return
        ;;
    esac;
    if [ $(__git_count_arguments "mv") -gt 0 ]; then
        __git_complete_index_file "--cached --others --directory";
    else
        __git_complete_index_file "--cached";
    fi
}
_git_notes () 
{ 
    local subcommands='add append copy edit get-ref list merge prune remove show';
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    case "$subcommand,$cur" in 
        ,--*)
            __gitcomp_builtin notes
        ;;
        ,*)
            case "$prev" in 
                --ref)
                    __git_complete_refs
                ;;
                *)
                    __gitcomp "$subcommands --ref"
                ;;
            esac
        ;;
        *,--reuse-message=* | *,--reedit-message=*)
            __git_complete_refs --cur="${cur#*=}"
        ;;
        *,--*)
            __gitcomp_builtin notes_$subcommand
        ;;
        prune,* | get-ref,*)

        ;;
        *)
            case "$prev" in 
                -m | -F)

                ;;
                *)
                    __git_complete_refs
                ;;
            esac
        ;;
    esac
}
_git_pull () 
{ 
    __git_complete_strategy && return;
    case "$cur" in 
        --recurse-submodules=*)
            __gitcomp "$__git_fetch_recurse_submodules" "" "${cur##--recurse-submodules=}";
            return
        ;;
        --*)
            __gitcomp_builtin pull;
            return
        ;;
    esac;
    __git_complete_remote_or_refspec
}
_git_push () 
{ 
    case "$prev" in 
        --repo)
            __gitcomp_nl "$(__git_remotes)";
            return
        ;;
        --recurse-submodules)
            __gitcomp "$__git_push_recurse_submodules";
            return
        ;;
    esac;
    case "$cur" in 
        --repo=*)
            __gitcomp_nl "$(__git_remotes)" "" "${cur##--repo=}";
            return
        ;;
        --recurse-submodules=*)
            __gitcomp "$__git_push_recurse_submodules" "" "${cur##--recurse-submodules=}";
            return
        ;;
        --force-with-lease=*)
            __git_complete_force_with_lease "${cur##--force-with-lease=}";
            return
        ;;
        --*)
            __gitcomp_builtin push;
            return
        ;;
    esac;
    __git_complete_remote_or_refspec
}
_git_range_diff () 
{ 
    case "$cur" in 
        --*)
            __gitcomp "
			--creation-factor= --no-dual-color
			$__git_diff_common_options
		";
            return
        ;;
    esac;
    __git_complete_revlist
}
_git_rebase () 
{ 
    __git_find_repo_path;
    if [ -f "$__git_repo_path"/rebase-merge/interactive ]; then
        __gitcomp "$__git_rebase_interactive_inprogress_options";
        return;
    else
        if [ -d "$__git_repo_path"/rebase-apply ] || [ -d "$__git_repo_path"/rebase-merge ]; then
            __gitcomp "$__git_rebase_inprogress_options";
            return;
        fi;
    fi;
    __git_complete_strategy && return;
    case "$cur" in 
        --whitespace=*)
            __gitcomp "$__git_whitespacelist" "" "${cur##--whitespace=}";
            return
        ;;
        --onto=*)
            __git_complete_refs --cur="${cur##--onto=}";
            return
        ;;
        --*)
            __gitcomp_builtin rebase "" "$__git_rebase_interactive_inprogress_options";
            return
        ;;
    esac;
    __git_complete_refs
}
_git_reflog () 
{ 
    local subcommands="show delete expire";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        __gitcomp "$subcommands";
    else
        __git_complete_refs;
    fi
}
_git_remote () 
{ 
    local subcommands="
		add rename remove set-head set-branches
		get-url set-url show prune update
		";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        case "$cur" in 
            --*)
                __gitcomp_builtin remote
            ;;
            *)
                __gitcomp "$subcommands"
            ;;
        esac;
        return;
    fi;
    case "$subcommand,$cur" in 
        add,--*)
            __gitcomp_builtin remote_add
        ;;
        add,*)

        ;;
        set-head,--*)
            __gitcomp_builtin remote_set-head
        ;;
        set-branches,--*)
            __gitcomp_builtin remote_set-branches
        ;;
        set-head,* | set-branches,*)
            __git_complete_remote_or_refspec
        ;;
        update,--*)
            __gitcomp_builtin remote_update
        ;;
        update,*)
            __gitcomp "$(__git_remotes) $(__git_get_config_variables "remotes")"
        ;;
        set-url,--*)
            __gitcomp_builtin remote_set-url
        ;;
        get-url,--*)
            __gitcomp_builtin remote_get-url
        ;;
        prune,--*)
            __gitcomp_builtin remote_prune
        ;;
        *)
            __gitcomp_nl "$(__git_remotes)"
        ;;
    esac
}
_git_replace () 
{ 
    case "$cur" in 
        --format=*)
            __gitcomp "short medium long" "" "${cur##--format=}";
            return
        ;;
        --*)
            __gitcomp_builtin replace;
            return
        ;;
    esac;
    __git_complete_refs
}
_git_rerere () 
{ 
    local subcommands="clear forget diff remaining status gc";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if test -z "$subcommand"; then
        __gitcomp "$subcommands";
        return;
    fi
}
_git_reset () 
{ 
    __git_has_doubledash && return;
    case "$cur" in 
        --*)
            __gitcomp_builtin reset;
            return
        ;;
    esac;
    __git_complete_refs
}
_git_restore () 
{ 
    __git_find_repo_path;
    case "$prev" in 
        -s)
            __git_complete_refs;
            return
        ;;
    esac;
    case "$cur" in 
        --conflict=*)
            __gitcomp "diff3 merge zdiff3" "" "${cur##--conflict=}"
        ;;
        --source=*)
            __git_complete_refs --cur="${cur##--source=}"
        ;;
        --*)
            __gitcomp_builtin restore
        ;;
        *)
            if __git_pseudoref_exists HEAD; then
                __git_complete_index_file "--modified";
            fi
        ;;
    esac
}
_git_revert () 
{ 
    __git_find_repo_path;
    if __git_pseudoref_exists REVERT_HEAD; then
        __gitcomp "$__git_revert_inprogress_options";
        return;
    fi;
    __git_complete_strategy && return;
    case "$cur" in 
        --*)
            __gitcomp_builtin revert "" "$__git_revert_inprogress_options";
            return
        ;;
    esac;
    __git_complete_refs
}
_git_rm () 
{ 
    case "$cur" in 
        --*)
            __gitcomp_builtin rm;
            return
        ;;
    esac;
    __git_complete_index_file "--cached"
}
_git_send_email () 
{ 
    case "$prev" in 
        --to | --cc | --bcc | --from)
            __gitcomp "$(__git send-email --dump-aliases)";
            return
        ;;
    esac;
    case "$cur" in 
        --confirm=*)
            __gitcomp "
			$__git_send_email_confirm_options
			" "" "${cur##--confirm=}";
            return
        ;;
        --suppress-cc=*)
            __gitcomp "
			$__git_send_email_suppresscc_options
			" "" "${cur##--suppress-cc=}";
            return
        ;;
        --smtp-encryption=*)
            __gitcomp "ssl tls" "" "${cur##--smtp-encryption=}";
            return
        ;;
        --thread=*)
            __gitcomp "
			deep shallow
			" "" "${cur##--thread=}";
            return
        ;;
        --to=* | --cc=* | --bcc=* | --from=*)
            __gitcomp "$(__git send-email --dump-aliases)" "" "${cur#--*=}";
            return
        ;;
        --*)
            __gitcomp_builtin send-email "$__git_format_patch_extra_options";
            return
        ;;
    esac;
    __git_complete_revlist
}
_git_shortlog () 
{ 
    __git_has_doubledash && return;
    case "$cur" in 
        --*)
            __gitcomp "
			$__git_log_common_options
			$__git_log_shortlog_options
			--numbered --summary --email
			";
            return
        ;;
    esac;
    __git_complete_revlist
}
_git_show () 
{ 
    __git_has_doubledash && return;
    case "$cur" in 
        --pretty=* | --format=*)
            __gitcomp "$__git_log_pretty_formats $(__git_pretty_aliases)
			" "" "${cur#*=}";
            return
        ;;
        --diff-algorithm=*)
            __gitcomp "$__git_diff_algorithms" "" "${cur##--diff-algorithm=}";
            return
        ;;
        --submodule=*)
            __gitcomp "$__git_diff_submodule_formats" "" "${cur##--submodule=}";
            return
        ;;
        --color-moved=*)
            __gitcomp "$__git_color_moved_opts" "" "${cur##--color-moved=}";
            return
        ;;
        --color-moved-ws=*)
            __gitcomp "$__git_color_moved_ws_opts" "" "${cur##--color-moved-ws=}";
            return
        ;;
        --ws-error-highlight=*)
            __gitcomp "$__git_ws_error_highlight_opts" "" "${cur##--ws-error-highlight=}";
            return
        ;;
        --diff-merges=*)
            __gitcomp "$__git_diff_merges_opts" "" "${cur##--diff-merges=}";
            return
        ;;
        --*)
            __gitcomp "--pretty= --format= --abbrev-commit --no-abbrev-commit
			--oneline --show-signature
			--expand-tabs --expand-tabs= --no-expand-tabs
			$__git_log_show_options
			$__git_diff_common_options
			";
            return
        ;;
    esac;
    __git_complete_revlist_file
}
_git_show_branch () 
{ 
    case "$cur" in 
        --*)
            __gitcomp_builtin show-branch;
            return
        ;;
    esac;
    __git_complete_revlist
}
_git_sparse_checkout () 
{ 
    local subcommands="list init set disable add reapply";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        __gitcomp "$subcommands";
        return;
    fi;
    case "$subcommand,$cur" in 
        *,--*)
            __gitcomp_builtin sparse-checkout_$subcommand "" "--"
        ;;
        set,* | add,*)
            if [ "$(__git config core.sparseCheckoutCone)" == "true" ] || [ -n "$(__git_find_on_cmdline --cone)" ]; then
                __gitcomp_directories;
            fi
        ;;
    esac
}
_git_stage () 
{ 
    _git_add
}
_git_stash () 
{ 
    local subcommands='push list show apply clear drop pop create branch';
    local subcommand="$(__git_find_on_cmdline "$subcommands save")";
    if [ -z "$subcommand" ]; then
        case "$((cword - __git_cmd_idx)),$cur" in 
            *,--*)
                __gitcomp_builtin stash_push
            ;;
            1,sa*)
                __gitcomp "save"
            ;;
            1,*)
                __gitcomp "$subcommands"
            ;;
        esac;
        return;
    fi;
    case "$subcommand,$cur" in 
        list,--*)
            __gitcomp_builtin stash_list "$__git_log_common_options $__git_diff_common_options"
        ;;
        show,--*)
            __gitcomp_builtin stash_show "$__git_diff_common_options"
        ;;
        *,--*)
            __gitcomp_builtin "stash_$subcommand"
        ;;
        branch,*)
            if [ $cword -eq $((__git_cmd_idx+2)) ]; then
                __git_complete_refs;
            else
                __gitcomp_nl "$(__git stash list 					| sed -n -e 's/:.*//p')";
            fi
        ;;
        show,* | apply,* | drop,* | pop,*)
            __gitcomp_nl "$(__git stash list 				| sed -n -e 's/:.*//p')"
        ;;
    esac
}
_git_status () 
{ 
    local complete_opt;
    local untracked_state;
    case "$cur" in 
        --ignore-submodules=*)
            __gitcomp "none untracked dirty all" "" "${cur##--ignore-submodules=}";
            return
        ;;
        --untracked-files=*)
            __gitcomp "$__git_untracked_file_modes" "" "${cur##--untracked-files=}";
            return
        ;;
        --column=*)
            __gitcomp "
			always never auto column row plain dense nodense
			" "" "${cur##--column=}";
            return
        ;;
        --*)
            __gitcomp_builtin status;
            return
        ;;
    esac;
    untracked_state="$(__git_get_option_value "-u" "--untracked-files=" 		"$__git_untracked_file_modes" "status.showUntrackedFiles")";
    case "$untracked_state" in 
        no)
            complete_opt=
        ;;
        all | normal | *)
            complete_opt="--cached --directory --no-empty-directory --others";
            if [ -n "$(__git_find_on_cmdline "--ignored")" ]; then
                complete_opt="$complete_opt --ignored --exclude=*";
            fi
        ;;
    esac;
    __git_complete_index_file "$complete_opt"
}
_git_submodule () 
{ 
    __git_has_doubledash && return;
    local subcommands="add status init deinit update set-branch set-url summary foreach sync absorbgitdirs";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        case "$cur" in 
            --*)
                __gitcomp "--quiet"
            ;;
            *)
                __gitcomp "$subcommands"
            ;;
        esac;
        return;
    fi;
    case "$subcommand,$cur" in 
        add,--*)
            __gitcomp "--branch --force --name --reference --depth"
        ;;
        status,--*)
            __gitcomp "--cached --recursive"
        ;;
        deinit,--*)
            __gitcomp "--force --all"
        ;;
        update,--*)
            __gitcomp "
			--init --remote --no-fetch
			--recommend-shallow --no-recommend-shallow
			--force --rebase --merge --reference --depth --recursive --jobs
		"
        ;;
        set-branch,--*)
            __gitcomp "--default --branch"
        ;;
        summary,--*)
            __gitcomp "--cached --files --summary-limit"
        ;;
        foreach,--* | sync,--*)
            __gitcomp "--recursive"
        ;;
        *)

        ;;
    esac
}
_git_svn () 
{ 
    local subcommands="
		init fetch clone rebase dcommit log find-rev
		set-tree commit-diff info create-ignore propget
		proplist show-ignore show-externals branch tag blame
		migrate mkdirs reset gc
		";
    local subcommand="$(__git_find_on_cmdline "$subcommands")";
    if [ -z "$subcommand" ]; then
        __gitcomp "$subcommands";
    else
        local remote_opts="--username= --config-dir= --no-auth-cache";
        local fc_opts="
			--follow-parent --authors-file= --repack=
			--no-metadata --use-svm-props --use-svnsync-props
			--log-window-size= --no-checkout --quiet
			--repack-flags --use-log-author --localtime
			--add-author-from
			--recursive
			--ignore-paths= --include-paths= $remote_opts
			";
        local init_opts="
			--template= --shared= --trunk= --tags=
			--branches= --stdlayout --minimize-url
			--no-metadata --use-svm-props --use-svnsync-props
			--rewrite-root= --prefix= $remote_opts
			";
        local cmt_opts="
			--edit --rmdir --find-copies-harder --copy-similarity=
			";
        case "$subcommand,$cur" in 
            fetch,--*)
                __gitcomp "--revision= --fetch-all $fc_opts"
            ;;
            clone,--*)
                __gitcomp "--revision= $fc_opts $init_opts"
            ;;
            init,--*)
                __gitcomp "$init_opts"
            ;;
            dcommit,--*)
                __gitcomp "
				--merge --strategy= --verbose --dry-run
				--fetch-all --no-rebase --commit-url
				--revision --interactive $cmt_opts $fc_opts
				"
            ;;
            set-tree,--*)
                __gitcomp "--stdin $cmt_opts $fc_opts"
            ;;
            create-ignore,--* | propget,--* | proplist,--* | show-ignore,--* | show-externals,--* | mkdirs,--*)
                __gitcomp "--revision="
            ;;
            log,--*)
                __gitcomp "
				--limit= --revision= --verbose --incremental
				--oneline --show-commit --non-recursive
				--authors-file= --color
				"
            ;;
            rebase,--*)
                __gitcomp "
				--merge --verbose --strategy= --local
				--fetch-all --dry-run $fc_opts
				"
            ;;
            commit-diff,--*)
                __gitcomp "--message= --file= --revision= $cmt_opts"
            ;;
            info,--*)
                __gitcomp "--url"
            ;;
            branch,--*)
                __gitcomp "--dry-run --message --tag"
            ;;
            tag,--*)
                __gitcomp "--dry-run --message"
            ;;
            blame,--*)
                __gitcomp "--git-format"
            ;;
            migrate,--*)
                __gitcomp "
				--config-dir= --ignore-paths= --minimize
				--no-auth-cache --username=
				"
            ;;
            reset,--*)
                __gitcomp "--revision= --parent"
            ;;
            *)

            ;;
        esac;
    fi
}
_git_switch () 
{ 
    local dwim_opt="$(__git_checkout_default_dwim_mode)";
    case "$prev" in 
        -c | -C | --orphan)
            __git_complete_refs $dwim_opt --mode="heads";
            return
        ;;
        *)

        ;;
    esac;
    case "$cur" in 
        --conflict=*)
            __gitcomp "diff3 merge zdiff3" "" "${cur##--conflict=}"
        ;;
        --*)
            __gitcomp_builtin switch
        ;;
        *)
            if [ -n "$(__git_find_on_cmdline "--orphan")" ]; then
                return;
            fi;
            if [ -n "$(__git_find_on_cmdline "-c -C -d --detach")" ]; then
                __git_complete_refs --mode="refs";
            else
                if [ -n "$(__git_find_on_cmdline "-t --track")" ]; then
                    __git_complete_refs --mode="remote-heads";
                else
                    __git_complete_refs $dwim_opt --mode="heads";
                fi;
            fi
        ;;
    esac
}
_git_tag () 
{ 
    local i c="$__git_cmd_idx" f=0;
    while [ $c -lt $cword ]; do
        i="${words[c]}";
        case "$i" in 
            -d | --delete | -v | --verify)
                __gitcomp_direct "$(__git_tags "" "$cur" " ")";
                return
            ;;
            -f)
                f=1
            ;;
        esac;
        ((c++));
    done;
    case "$prev" in 
        -m | -F)

        ;;
        -* | tag)
            if [ $f = 1 ]; then
                __gitcomp_direct "$(__git_tags "" "$cur" " ")";
            fi
        ;;
        *)
            __git_complete_refs
        ;;
    esac;
    case "$cur" in 
        --*)
            __gitcomp_builtin tag
        ;;
    esac
}
_git_whatchanged () 
{ 
    _git_log
}
_git_worktree () 
{ 
    local subcommands="add list lock move prune remove unlock";
    local subcommand subcommand_idx;
    subcommand="$(__git_find_on_cmdline --show-idx "$subcommands")";
    subcommand_idx="${subcommand% *}";
    subcommand="${subcommand#* }";
    case "$subcommand,$cur" in 
        ,*)
            __gitcomp "$subcommands"
        ;;
        *,--*)
            __gitcomp_builtin worktree_$subcommand
        ;;
        add,*)
            case "$prev" in 
                -b | -B)
                    __git_complete_refs
                ;;
                -*)

                ;;
                *)
                    if [ $cword -eq $((subcommand_idx+1)) ]; then
                        :;
                    else
                        case "${words[cword-2]}" in 
                            -b | -B)

                            ;;
                            *)
                                __git_complete_refs
                            ;;
                        esac;
                    fi
                ;;
            esac
        ;;
        lock,* | remove,* | unlock,*)
            __git_complete_worktree_paths
        ;;
        move,*)
            if [ $cword -eq $((subcommand_idx+1)) ]; then
                __git_complete_worktree_paths;
            else
                :;
            fi
        ;;
    esac
}
_have () 
{ 
    PATH=$PATH:/usr/sbin:/sbin:/usr/local/sbin type $1 &> /dev/null
}
_included_ssh_config_files () 
{ 
    (($# < 1)) && echo "bash_completion: $FUNCNAME: missing mandatory argument CONFIG" 1>&2;
    local configfile i f;
    configfile=$1;
    local reset=$(shopt -po noglob);
    set -o noglob;
    local included=($(command sed -ne 's/^[[:blank:]]*[Ii][Nn][Cc][Ll][Uu][Dd][Ee][[:blank:]]\(.*\)$/\1/p' "${configfile}"));
    $reset;
    [[ -n ${included-} ]] || return;
    for i in "${included[@]}";
    do
        if ! [[ $i =~ ^\~.*|^\/.* ]]; then
            if [[ $configfile =~ ^\/etc\/ssh.* ]]; then
                i="/etc/ssh/$i";
            else
                i="$HOME/.ssh/$i";
            fi;
        fi;
        __expand_tilde_by_ref i;
        set +o noglob;
        for f in $i;
        do
            if [[ -r $f ]]; then
                config+=("$f");
                _included_ssh_config_files $f;
            fi;
        done;
        $reset;
    done
}
_init_completion () 
{ 
    local exclude="" flag outx errx inx OPTIND=1;
    while getopts "n:e:o:i:s" flag "$@"; do
        case $flag in 
            n)
                exclude+=$OPTARG
            ;;
            e)
                errx=$OPTARG
            ;;
            o)
                outx=$OPTARG
            ;;
            i)
                inx=$OPTARG
            ;;
            s)
                split=false;
                exclude+==
            ;;
            *)
                echo "bash_completion: $FUNCNAME: usage error" 1>&2;
                return 1
            ;;
        esac;
    done;
    COMPREPLY=();
    local redir="@(?([0-9])<|?([0-9&])>?(>)|>&)";
    _get_comp_words_by_ref -n "$exclude<>&" cur prev words cword;
    _variables && return 1;
    if [[ $cur == $redir* || ${prev-} == $redir ]]; then
        local xspec;
        case $cur in 
            2'>'*)
                xspec=${errx-}
            ;;
            *'>'*)
                xspec=${outx-}
            ;;
            *'<'*)
                xspec=${inx-}
            ;;
            *)
                case $prev in 
                    2'>'*)
                        xspec=${errx-}
                    ;;
                    *'>'*)
                        xspec=${outx-}
                    ;;
                    *'<'*)
                        xspec=${inx-}
                    ;;
                esac
            ;;
        esac;
        cur="${cur##$redir}";
        _filedir $xspec;
        return 1;
    fi;
    local i skip;
    for ((i = 1; i < ${#words[@]}; 1))
    do
        if [[ ${words[i]} == $redir* ]]; then
            [[ ${words[i]} == $redir ]] && skip=2 || skip=1;
            words=("${words[@]:0:i}" "${words[@]:i+skip}");
            ((i <= cword)) && ((cword -= skip));
        else
            ((i++));
        fi;
    done;
    ((cword <= 0)) && return 1;
    prev=${words[cword - 1]};
    [[ -n ${split-} ]] && _split_longopt && split=true;
    return 0
}
_installed_modules () 
{ 
    COMPREPLY=($(compgen -W "$(PATH="$PATH:/sbin" lsmod |
        awk '{if (NR != 1) print $1}')" -- "$1"))
}
_ip_addresses () 
{ 
    local n;
    case ${1-} in 
        -a)
            n='6\?'
        ;;
        -6)
            n='6'
        ;;
        *)
            n=
        ;;
    esac;
    local PATH=$PATH:/sbin;
    local addrs=$({
        LC_ALL=C ifconfig -a || ip addr show
    } 2>/dev/null |
        command sed -e 's/[[:space:]]addr:/ /' -ne             "s|.*inet${n}[[:space:]]\{1,\}\([^[:space:]/]*\).*|\1|p");
    COMPREPLY+=($(compgen -W "$addrs" -- "${cur-}"))
}
_ipa () 
{ 
    cur=${COMP_WORDS[COMP_CWORD]};
    prev=${COMP_WORDS[COMP_CWORD-1]};
    if [ $COMP_CWORD -eq 1 ]; then
        COMPREPLY=($( compgen -W "$(_ipa_commands)" $cur ));
    else
        if [ $COMP_CWORD -eq 2 ]; then
            case "$prev" in 
                help)
                    COMPREPLY=($( compgen -W "$(_ipa_commands) commands" $cur ))
                ;;
            esac;
        fi;
    fi
}
_ipa_commands () 
{ 
    ipa help commands 2> /dev/null | sed -r 's/^([-[:alnum:]]*).*/\1/' | grep '^[[:alnum:]]'
}
_kernel_versions () 
{ 
    COMPREPLY=($(compgen -W '$(command ls /lib/modules)' -- "$cur"))
}
_known_hosts () 
{ 
    local cur prev words cword;
    _init_completion -n : || return;
    local options;
    [[ ${1-} == -a || ${2-} == -a ]] && options=-a;
    [[ ${1-} == -c || ${2-} == -c ]] && options+=" -c";
    _known_hosts_real ${options-} -- "$cur"
}
_known_hosts_real () 
{ 
    local configfile flag prefix="" ifs=$IFS;
    local cur suffix="" aliases i host ipv4 ipv6;
    local -a kh tmpkh=() khd=() config=();
    local OPTIND=1;
    while getopts "ac46F:p:" flag "$@"; do
        case $flag in 
            a)
                aliases='yes'
            ;;
            c)
                suffix=':'
            ;;
            F)
                configfile=$OPTARG
            ;;
            p)
                prefix=$OPTARG
            ;;
            4)
                ipv4=1
            ;;
            6)
                ipv6=1
            ;;
            *)
                echo "bash_completion: $FUNCNAME: usage error" 1>&2;
                return 1
            ;;
        esac;
    done;
    if (($# < OPTIND)); then
        echo "bash_completion: $FUNCNAME: missing mandatory argument CWORD" 1>&2;
        return 1;
    fi;
    cur=${!OPTIND};
    ((OPTIND += 1));
    if (($# >= OPTIND)); then
        echo "bash_completion: $FUNCNAME($*): unprocessed arguments:" "$(while (($# >= OPTIND)); do
                printf '%s ' ${!OPTIND}
                shift
            done)" 1>&2;
        return 1;
    fi;
    [[ $cur == *@* ]] && prefix=$prefix${cur%@*}@ && cur=${cur#*@};
    kh=();
    if [[ -v configfile ]]; then
        [[ -r $configfile ]] && config+=("$configfile");
    else
        for i in /etc/ssh/ssh_config ~/.ssh/config ~/.ssh2/config;
        do
            [[ -r $i ]] && config+=("$i");
        done;
    fi;
    local reset=$(shopt -po noglob);
    set -o noglob;
    if ((${#config[@]} > 0)); then
        for i in "${config[@]}";
        do
            _included_ssh_config_files "$i";
        done;
    fi;
    if ((${#config[@]} > 0)); then
        local IFS='
';
        tmpkh=($(awk 'sub("^[ \t]*([Gg][Ll][Oo][Bb][Aa][Ll]|[Uu][Ss][Ee][Rr])[Kk][Nn][Oo][Ww][Nn][Hh][Oo][Ss][Tt][Ss][Ff][Ii][Ll][Ee][ \t]+", "") { print $0 }' "${config[@]}" | sort -u));
        IFS=$ifs;
    fi;
    if ((${#tmpkh[@]} != 0)); then
        local j;
        for i in "${tmpkh[@]}";
        do
            while [[ $i =~ ^([^\"]*)\"([^\"]*)\"(.*)$ ]]; do
                i=${BASH_REMATCH[1]}${BASH_REMATCH[3]};
                j=${BASH_REMATCH[2]};
                __expand_tilde_by_ref j;
                [[ -r $j ]] && kh+=("$j");
            done;
            for j in $i;
            do
                __expand_tilde_by_ref j;
                [[ -r $j ]] && kh+=("$j");
            done;
        done;
    fi;
    if [[ ! -v configfile ]]; then
        for i in /etc/ssh/ssh_known_hosts /etc/ssh/ssh_known_hosts2 /etc/known_hosts /etc/known_hosts2 ~/.ssh/known_hosts ~/.ssh/known_hosts2;
        do
            [[ -r $i ]] && kh+=("$i");
        done;
        for i in /etc/ssh2/knownhosts ~/.ssh2/hostkeys;
        do
            [[ -d $i ]] && khd+=("$i"/*pub);
        done;
    fi;
    if ((${#kh[@]} + ${#khd[@]} > 0)); then
        if ((${#kh[@]} > 0)); then
            for i in "${kh[@]}";
            do
                while read -ra tmpkh; do
                    ((${#tmpkh[@]} == 0)) && continue;
                    set -- "${tmpkh[@]}";
                    [[ $1 == [\|\#]* ]] && continue;
                    [[ $1 == @* ]] && shift;
                    local IFS=,;
                    for host in $1;
                    do
                        [[ $host == *[*?]* ]] && continue;
                        host="${host#[}";
                        host="${host%]?(:+([0-9]))}";
                        COMPREPLY+=($host);
                    done;
                    IFS=$ifs;
                done < "$i";
            done;
            COMPREPLY=($(compgen -W '${COMPREPLY[@]}' -- "$cur"));
        fi;
        if ((${#khd[@]} > 0)); then
            for i in "${khd[@]}";
            do
                if [[ $i == *key_22_$cur*.pub && -r $i ]]; then
                    host=${i/#*key_22_/};
                    host=${host/%.pub/};
                    COMPREPLY+=($host);
                fi;
            done;
        fi;
        for i in ${!COMPREPLY[*]};
        do
            COMPREPLY[i]=$prefix${COMPREPLY[i]}$suffix;
        done;
    fi;
    if [[ ${#config[@]} -gt 0 && -v aliases ]]; then
        local -a hosts=($(command sed -ne 's/^[[:blank:]]*[Hh][Oo][Ss][Tt][[:blank:]]\(.*\)$/\1/p' "${config[@]}"));
        if ((${#hosts[@]} != 0)); then
            COMPREPLY+=($(compgen -P "$prefix"                 -S "$suffix" -W '${hosts[@]%%[*?%]*}' -X '\!*' -- "$cur"));
        fi;
    fi;
    if [[ -n ${COMP_KNOWN_HOSTS_WITH_AVAHI-} ]] && type avahi-browse &> /dev/null; then
        COMPREPLY+=($(compgen -P "$prefix" -S "$suffix" -W             "$(avahi-browse -cpr _workstation._tcp 2>/dev/null |
                awk -F';' '/^=/ { print $7 }' | sort -u)" -- "$cur"));
    fi;
    if type ruptime &> /dev/null; then
        COMPREPLY+=($(compgen -W             "$(ruptime 2>/dev/null | awk '!/^ruptime:/ { print $1 }')"             -- "$cur"));
    fi;
    if [[ -n ${COMP_KNOWN_HOSTS_WITH_HOSTFILE-1} ]]; then
        COMPREPLY+=($(compgen -A hostname -P "$prefix" -S "$suffix" -- "$cur"));
    fi;
    $reset;
    if [[ -v ipv4 ]]; then
        COMPREPLY=("${COMPREPLY[@]/*:*$suffix/}");
    fi;
    if [[ -v ipv6 ]]; then
        COMPREPLY=("${COMPREPLY[@]/+([0-9]).+([0-9]).+([0-9]).+([0-9])$suffix/}");
    fi;
    if [[ -v ipv4 || -v ipv6 ]]; then
        for i in "${!COMPREPLY[@]}";
        do
            [[ -n ${COMPREPLY[i]} ]] || unset -v "COMPREPLY[i]";
        done;
    fi;
    __ltrim_colon_completions "$prefix$cur"
}
_lldpad_options () 
{ 
    local cur prev opts;
    COMPREPLY=();
    cur="${COMP_WORDS[COMP_CWORD]}";
    prev="${COMP_WORDS[COMP_CWORD-1]}";
    opts="-h -f -d -k -s -v -V";
    case "${cur}" in 
        *)
            COMPREPLY=($(compgen -W "${opts}" -- ${cur}))
        ;;
    esac;
    case "${prev}" in 
        -f)
            _filedir;
            return 0
        ;;
    esac;
    return 0
}
_lldptool_options () 
{ 
    local cur prev opts cmds opts_and_cmds;
    COMPREPLY=();
    cur="${COMP_WORDS[COMP_CWORD]}";
    prev="${COMP_WORDS[COMP_CWORD-1]}";
    cmds="license -h help -v version -q quit -s stats -t get-tlv -T set-tlv -l get-lldp -L set-lldp";
    opts="-i -V -n -a -d -r -R";
    opts_and_cmds="$opts $cmds";
    case "${cur}" in 
        *)
            COMPREPLY=($(compgen -W "${opts_and_cmds}" -- ${cur}))
        ;;
    esac;
    case "${prev}" in 
        -i)
            _available_interfaces;
            return 0
        ;;
    esac;
    return 0
}
_longopt () 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    case "${prev,,}" in 
        --help | --usage | --version)
            return
        ;;
        --!(no-*)dir*)
            _filedir -d;
            return
        ;;
        --!(no-*)@(file|path)*)
            _filedir;
            return
        ;;
        --+([-a-z0-9_]))
            local argtype=$(LC_ALL=C $1 --help 2>&1 | command sed -ne                 "s|.*$prev\[\{0,1\}=[<[]\{0,1\}\([-A-Za-z0-9_]\{1,\}\).*|\1|p");
            case ${argtype,,} in 
                *dir*)
                    _filedir -d;
                    return
                ;;
                *file* | *path*)
                    _filedir;
                    return
                ;;
            esac
        ;;
    esac;
    $split && return;
    if [[ $cur == -* ]]; then
        COMPREPLY=($(compgen -W "$(LC_ALL=C $1 --help 2>&1 |
            while read -r line; do
                [[ $line =~ --[A-Za-z0-9]+([-_][A-Za-z0-9]+)*=? ]] &&
                    printf '%s\n' ${BASH_REMATCH[0]}
            done)" -- "$cur"));
        [[ ${COMPREPLY-} == *= ]] && compopt -o nospace;
    else
        if [[ $1 == *@(rmdir|chroot) ]]; then
            _filedir -d;
        else
            [[ $1 == *mkdir ]] && compopt -o nospace;
            _filedir;
        fi;
    fi
}
_mac_addresses () 
{ 
    local re='\([A-Fa-f0-9]\{2\}:\)\{5\}[A-Fa-f0-9]\{2\}';
    local PATH="$PATH:/sbin:/usr/sbin";
    COMPREPLY+=($(
        {
            LC_ALL=C ifconfig -a || ip link show
        } 2>/dev/null | command sed -ne             "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]].*/\1/p" -ne             "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]]*$/\1/p" -ne             "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($re\)[[:space:]].*|\2|p" -ne             "s|.*[[:space:]]\(link/\)\{0,1\}ether[[:space:]]\{1,\}\($re\)[[:space:]]*$|\2|p"
    ));
    COMPREPLY+=($({
        arp -an || ip neigh show
    } 2>/dev/null | command sed -ne         "s/.*[[:space:]]\($re\)[[:space:]].*/\1/p" -ne         "s/.*[[:space:]]\($re\)[[:space:]]*$/\1/p"));
    COMPREPLY+=($(command sed -ne         "s/^[[:space:]]*\($re\)[[:space:]].*/\1/p" /etc/ethers 2>/dev/null));
    COMPREPLY=($(compgen -W '${COMPREPLY[@]}' -- "$cur"));
    __ltrim_colon_completions "$cur"
}
_minimal () 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    $split && return;
    _filedir
}
_ml () 
{ 
    local cur="${2}" prev="${3}" cmds opts found;
    COMPREPLY=();
    cmds="add avail describe disable delete help keyword list load overview purge refresh restore rm        save show spider swap try-load unload unuse update use whatis";
    opts="-d -D -h -q -t -v -w -s --style --expert --quiet --help -H -b --brief         --quiet --terse --version --default --width -r --regexp --mt --latest         -I --ignore_cache --gitversion --dumpversion --dumpname --config              --miniConfig --timer -f --force --redirect --show_hidden -T --trace           --nx --no_extensions --loc --location --terse_show_extensions --pod           -A --all";
    case "${prev}" in 
        rm | remove | unload | switch | swap)
            COMPREPLY=($(compgen -W "$(_module_loaded_modules)" -- "${cur}"))
        ;;
        restore)
            COMPREPLY=($(compgen -W "$(_module_savelist)" -- "${cur}"))
        ;;
        spider)
            COMPREPLY=($(compgen -W "$(_module_spider)" -- "${cur}"))
        ;;
        unuse)
            COMPREPLY=($(IFS=: compgen -W "${MODULEPATH}" -- "${cur}"))
        ;;
        use | *-a*)
            _module_dir "${cur}"
        ;;
        help | show | whatis)
            COMPREPLY=($(compgen -W "$(_module_avail)" -- "${cur}"))
        ;;
        *)
            case "${cur}" in 
                -*)
                    if [ ${COMP_CWORD} -eq 1 ]; then
                        COMPREPLY=($(compgen -W "${opts} $(_module_loaded_modules_negated)" -- "${cur}"));
                    else
                        COMPREPLY=($(compgen -W "        $(_module_loaded_modules_negated)" -- "${cur}"));
                    fi
                ;;
                *)
                    if [ ${COMP_CWORD} -eq 1 ]; then
                        case "${cur}" in 
                            ls)
                                COMPREPLY='list'
                            ;;
                            sw*)
                                COMPREPLY='swap'
                            ;;
                            *)
                                COMPREPLY=($(compgen -W "${cmds} $(_module_avail)" -- "${cur}"))
                            ;;
                        esac;
                    else
                        if [[ ${COMP_WORDS[COMP_CWORD-2]} == sw* ]]; then
                            COMPREPLY=($(compgen -W "$(_module_not_yet_loaded)" -- "${cur}"));
                        else
                            for ((i = COMP_CWORD - 1; i > 0; i--))
                            do
                                case ${COMP_WORDS[$i]} in 
                                    show | whatis)
                                        COMPREPLY=($(compgen -W "$(_module_avail)" -- "${cur}"));
                                        found=1;
                                        break
                                    ;;
                                    rm | remove | unload)
                                        COMPREPLY=($(compgen -W "$(_module_loaded_modules)" -- "${cur}"));
                                        found=1;
                                        break
                                    ;;
                                    spider)
                                        COMPREPLY=($(compgen -W "$(_module_spider)" -- "${cur}"));
                                        found=1;
                                        break
                                    ;;
                                esac;
                            done;
                            if [ -z "${found}" ]; then
                                COMPREPLY=($(compgen -W "$(_module_avail)" -- "${cur}"));
                            fi;
                        fi;
                    fi
                ;;
            esac
        ;;
    esac
}
_module () 
{ 
    local cur="${2}" prev="${3}" cmds opts;
    COMPREPLY=();
    cmds="add avail describe disable delete help keyword list load overview purge refresh restore rm        save show spider swap try-load unload unuse update use whatis";
    opts="-d -D -h -q -t -v -w -s --style --expert --quiet --help -H -b --brief         --quiet --terse --version --default --width -r --regexp --mt --latest         -I --ignore_cache --gitversion --dumpversion --dumpname --config              --miniConfig --timer -f --force --redirect --show_hidden -T --trace           --nx --no_extensions --loc --location --terse_show_extensions --pod           -A --all";
    case "${prev}" in 
        add | load | try-load)
            COMPREPLY=($(compgen -W "$(_module_not_yet_loaded)" -- "${cur}"))
        ;;
        rm | remove | unload | switch | swap)
            COMPREPLY=($(compgen -W "$(_module_loaded_modules)" -- "${cur}"))
        ;;
        restore)
            COMPREPLY=($(compgen -W "$(_module_savelist)" -- "${cur}"))
        ;;
        spider)
            COMPREPLY=($(compgen -W "$(_module_spider)" -- "${cur}"))
        ;;
        unuse)
            COMPREPLY=($(IFS=: compgen -W "${MODULEPATH}" -- "${cur}"))
        ;;
        use | *-a*)
            _module_dir "${cur}"
        ;;
        help | show | whatis)
            COMPREPLY=($(compgen -W "$(_module_avail)" -- "${cur}"))
        ;;
        describe | mcc)
            COMPREPLY=($(compgen -W "$(_module_mcc)" -- "${cur}"))
        ;;
        disable)
            COMPREPLY=($(compgen -W "$(_module_mcc)" -- "${cur}"))
        ;;
        *)
            if [ ${COMP_CWORD} -gt 2 ]; then
                _module_long_arg_list "${cur}";
            else
                case "${cur}" in 
                    ls)
                        COMPREPLY='list'
                    ;;
                    sw*)
                        COMPREPLY='swap'
                    ;;
                    -*)
                        COMPREPLY=($(compgen -W "${opts}" -- "${cur}"))
                    ;;
                    *)
                        COMPREPLY=($(compgen -W "${cmds}" -- "${cur}"))
                    ;;
                esac;
            fi
        ;;
    esac
}
_module_avail () 
{ 
    /usr/share/lmod/lmod/libexec/lmod bash --no_redirect -t -q avail 2>&1 > /dev/null | sed ' /:$/d; s/(@.*)//g; s#/*$##g; s/ *<[A-Za-z][A-Za-z]*>//;'
}
_module_describe () 
{ 
    /usr/share/lmod/lmod/libexec/lmod bash -q -t --no_redirect savelist 2>&1 > /dev/null
}
_module_dir () 
{ 
    local cur="${1}" pattern i;
    if [[ "${cur:0:1}" == '$' ]]; then
        pattern='^\$[[:alnum:]_]+\/$';
        if [[ ${cur} =~ ${pattern} ]]; then
            eval COMPREPLY[0]="${cur}";
        else
            COMPREPLY=($( compgen -v -P '$' -- "${cur:1}" ));
            local -a FILTEREDCOMPREPLY;
            for ((i=0; i < ${#COMPREPLY[@]}; i++))
            do
                pattern='^\$[[:alnum:]_]+$';
                if [[ ${COMPREPLY[$i]} =~ ${pattern} ]]; then
                    eval local env_val="${COMPREPLY[$i]}";
                    if [ -d "${env_val}" ]; then
                        FILTEREDCOMPREPLY+=(${COMPREPLY[$i]});
                    fi;
                fi;
            done;
            COMPREPLY=(${FILTEREDCOMPREPLY[@]});
        fi;
    else
        if [[ "${cur:0:1}" == '~' ]]; then
            if [[ "${cur}" != "${cur//\/}" ]]; then
                eval COMPREPLY[0]="${cur%%\/*}"/'${cur#*\/}';
            else
                eval COMPREPLY[0]="~";
            fi;
        else
            COMPREPLY=($(compgen -d -- "${cur}"));
        fi;
    fi;
    if [[ ${#COMPREPLY[@]} -eq 1 ]]; then
        pattern='\/$';
        if [[ -d "${COMPREPLY[0]}" && ! "${COMPREPLY[0]}" =~ ${pattern} ]]; then
            COMPREPLY[0]="${COMPREPLY[0]}/";
        fi;
        compopt -o nospace;
    fi
}
_module_disable () 
{ 
    /usr/share/lmod/lmod/libexec/lmod bash -q -t --no_redirect savelist 2>&1 > /dev/null
}
_module_loaded_modules () 
{ 
    /usr/share/lmod/lmod/libexec/lmod bash -q -t --no_redirect list 2>&1 > /dev/null | sed ' /^ *$/d; /:$/d; s#/*$##g; s/ *<[A-Za-z][A-Za-z]*>//'
}
_module_loaded_modules_negated () 
{ 
    /usr/share/lmod/lmod/libexec/lmod bash -q -t --no_redirect list 2>&1 > /dev/null | sed ' /^ *$/d; /:$/d; s#/*$##g; s|^|-|g; s/ *<[A-Za-z][A-Za-z]*>//'
}
_module_long_arg_list () 
{ 
    local cur="${1}" i;
    if [[ ${COMP_WORDS[COMP_CWORD-2]} == sw* ]]; then
        COMPREPLY=($(compgen -W "$(_module_not_yet_loaded)" -- "${cur}"));
        return;
    fi;
    for ((i = COMP_CWORD - 1; i > 0; i--))
    do
        case ${COMP_WORDS[${i}]} in 
            add | load)
                COMPREPLY=($(compgen -W "$(_module_not_yet_loaded)" -- "${cur}"));
                break
            ;;
            rm | remove | unload | switch | swap)
                COMPREPLY=($(compgen -W "$(_module_loaded_modules)" -- "${cur}"));
                break
            ;;
        esac;
    done
}
_module_mcc () 
{ 
    /usr/share/lmod/lmod/libexec/lmod bash -q -t --no_redirect savelist 2>&1 > /dev/null
}
_module_not_yet_loaded () 
{ 
    comm -23 <(_module_avail|sort) <(_module_loaded_modules|sort)
}
_module_savelist () 
{ 
    /usr/share/lmod/lmod/libexec/lmod bash -q -t --no_redirect savelist 2>&1 > /dev/null
}
_module_spider () 
{ 
    /usr/share/lmod/lmod/libexec/lmod bash -q -t --no_redirect spider 2>&1 > /dev/null
}
_modules () 
{ 
    local modpath;
    modpath=/lib/modules/$1;
    COMPREPLY=($(compgen -W "$(command ls -RL $modpath 2>/dev/null |
        command sed -ne 's/^\(.*\)\.k\{0,1\}o\(\.[gx]z\)\{0,1\}$/\1/p')" -- "$cur"))
}
_ncpus () 
{ 
    local var=NPROCESSORS_ONLN;
    [[ $OSTYPE == *linux* ]] && var=_$var;
    local n=$(getconf $var 2>/dev/null);
    printf %s ${n:-1}
}
_parse_help () 
{ 
    eval local cmd="$(quote "$1")";
    local line;
    { 
        case $cmd in 
            -)
                cat
            ;;
            *)
                LC_ALL=C "$(dequote "$cmd")" ${2:---help} 2>&1
            ;;
        esac
    } | while read -r line; do
        [[ $line == *([[:blank:]])-* ]] || continue;
        while [[ $line =~ ((^|[^-])-[A-Za-z0-9?][[:space:]]+)\[?[A-Z0-9]+([,_-]+[A-Z0-9]+)?(\.\.+)?\]? ]]; do
            line=${line/"${BASH_REMATCH[0]}"/"${BASH_REMATCH[1]}"};
        done;
        __parse_options "${line// or /, }";
    done
}
_parse_usage () 
{ 
    eval local cmd="$(quote "$1")";
    local line match option i char;
    { 
        case $cmd in 
            -)
                cat
            ;;
            *)
                LC_ALL=C "$(dequote "$cmd")" ${2:---usage} 2>&1
            ;;
        esac
    } | while read -r line; do
        while [[ $line =~ \[[[:space:]]*(-[^]]+)[[:space:]]*\] ]]; do
            match=${BASH_REMATCH[0]};
            option=${BASH_REMATCH[1]};
            case $option in 
                -?(\[)+([a-zA-Z0-9?]))
                    for ((i = 1; i < ${#option}; i++))
                    do
                        char=${option:i:1};
                        [[ $char != '[' ]] && printf '%s\n' -$char;
                    done
                ;;
                *)
                    __parse_options "$option"
                ;;
            esac;
            line=${line#*"$match"};
        done;
    done
}
_pci_ids () 
{ 
    COMPREPLY+=($(compgen -W         "$(PATH="$PATH:/sbin" lspci -n | awk '{print $3}')" -- "$cur"))
}
_pdftotext () 
{ 
    local cur prev words cword;
    _init_completion || return;
    case $prev in 
        -h | -help | --help | -'?' | -f | -l | -r | -x | -y | -W | -H | -fixed | -opw | -upw)
            return
        ;;
        -enc)
            COMPREPLY=($(compgen -W '$("$1" -listenc 2>/dev/null |
                command sed -e 1d)' -- "$cur"));
            return
        ;;
        -eol)
            COMPREPLY=($(compgen -W "unix dos mac" -- "$cur"));
            return
        ;;
    esac;
    if [[ $cur == -* && ${prev,,} != *.pdf ]]; then
        COMPREPLY=($(compgen -W '$(_parse_help "$1")' -- "$cur"));
        return;
    fi;
    case ${prev,,} in 
        - | *.txt)

        ;;
        *.pdf)
            COMPREPLY=($(compgen -W '-' -- "$cur"));
            _filedir txt
        ;;
        *)
            _filedir pdf
        ;;
    esac
}
_perf () 
{ 
    if [[ "$COMP_WORDBREAKS" != *,* ]]; then
        COMP_WORDBREAKS="${COMP_WORDBREAKS},";
        export COMP_WORDBREAKS;
    fi;
    if [[ "$COMP_WORDBREAKS" == *:* ]]; then
        COMP_WORDBREAKS="${COMP_WORDBREAKS/:/}";
        export COMP_WORDBREAKS;
    fi;
    local cur words cword prev;
    if [ $preload_get_comp_words_by_ref = "true" ]; then
        _get_comp_words_by_ref -n =:, cur words cword prev;
    else
        __perf_get_comp_words_by_ref -n =:, cur words cword prev;
    fi;
    __perf_main
}
_pgids () 
{ 
    COMPREPLY=($(compgen -W '$(command ps axo pgid=)' -- "$cur"))
}
_pids () 
{ 
    COMPREPLY=($(compgen -W '$(command ps axo pid=)' -- "$cur"))
}
_pnames () 
{ 
    local -a procs;
    if [[ ${1-} == -s ]]; then
        procs=($(command ps axo comm | command sed -e 1d));
    else
        local line i=-1 ifs=$IFS;
        IFS='
';
        local -a psout=($(command ps axo command=));
        IFS=$ifs;
        for line in "${psout[@]}";
        do
            if ((i == -1)); then
                if [[ $line =~ ^(.*[[:space:]])COMMAND([[:space:]]|$) ]]; then
                    i=${#BASH_REMATCH[1]};
                else
                    break;
                fi;
            else
                line=${line:i};
                line=${line%% *};
                procs+=($line);
            fi;
        done;
        if ((i == -1)); then
            for line in "${psout[@]}";
            do
                if [[ $line =~ ^[[(](.+)[])]$ ]]; then
                    procs+=(${BASH_REMATCH[1]});
                else
                    line=${line%% *};
                    line=${line##@(*/|-)};
                    procs+=($line);
                fi;
            done;
        fi;
    fi;
    COMPREPLY=($(compgen -X "<defunct>" -W '${procs[@]}' -- "$cur"))
}
_python_argcomplete () 
{ 
    local IFS='';
    local SUPPRESS_SPACE=0;
    if compopt +o nospace 2> /dev/null; then
        SUPPRESS_SPACE=1;
    fi;
    COMPREPLY=($(IFS="$IFS"                   COMP_LINE="$COMP_LINE"                   COMP_POINT="$COMP_POINT"                   COMP_TYPE="$COMP_TYPE"                   _ARGCOMPLETE_COMP_WORDBREAKS="$COMP_WORDBREAKS"                   _ARGCOMPLETE=1                   _ARGCOMPLETE_SUPPRESS_SPACE=$SUPPRESS_SPACE                   __python_argcomplete_run "$1"));
    if [[ $? != 0 ]]; then
        unset COMPREPLY;
    else
        if [[ $SUPPRESS_SPACE == 1 ]] && [[ "$COMPREPLY" =~ [=/:]$ ]]; then
            compopt -o nospace;
        fi;
    fi
}
_python_argcomplete_global () 
{ 
    local executable=$1;
    __python_argcomplete_expand_tilde_by_ref executable;
    local ARGCOMPLETE=0;
    if [[ "$executable" == python* ]] || [[ "$executable" == pypy* ]]; then
        if [[ "${COMP_WORDS[1]}" == -m ]]; then
            if __python_argcomplete_run "$executable" -m argcomplete._check_module "${COMP_WORDS[2]}"; then
                ARGCOMPLETE=3;
            else
                return;
            fi;
        else
            if [[ -f "${COMP_WORDS[1]}" ]] && __python_argcomplete_scan_head_noerr "${COMP_WORDS[1]}"; then
                local ARGCOMPLETE=2;
            else
                return;
            fi;
        fi;
    else
        if type -P "$executable" > /dev/null 2>&1; then
            local SCRIPT_NAME=$(type -P "$executable");
            if ( type -t pyenv && [[ "$SCRIPT_NAME" = $(pyenv root)/shims/* ]] ) > /dev/null 2>&1; then
                local SCRIPT_NAME=$(pyenv which "$executable");
            fi;
            if __python_argcomplete_scan_head_noerr "$SCRIPT_NAME"; then
                local ARGCOMPLETE=1;
            else
                if __python_argcomplete_scan_head_noerr "$SCRIPT_NAME" '^#!(.*)$' -n && [[ "${BASH_REMATCH[1]}" =~ ^.*(python|pypy)[0-9\.]*$ ]]; then
                    local interpreter="$BASH_REMATCH";
                    if ( __python_argcomplete_scan_head_noerr "$SCRIPT_NAME" "(PBR Generated)|(EASY-INSTALL-(SCRIPT|ENTRY-SCRIPT|DEV-SCRIPT))" && "$interpreter" "$(type -P python-argcomplete-check-easy-install-script)" "$SCRIPT_NAME" ) > /dev/null 2>&1; then
                        local ARGCOMPLETE=1;
                    else
                        if __python_argcomplete_run "$interpreter" -m argcomplete._check_console_script "$SCRIPT_NAME"; then
                            local ARGCOMPLETE=1;
                        fi;
                    fi;
                fi;
            fi;
        fi;
    fi;
    if [[ $ARGCOMPLETE != 0 ]]; then
        local IFS=$(echo -e '\v');
        COMPREPLY=($(_ARGCOMPLETE_IFS="$IFS"             COMP_LINE="$COMP_LINE"             COMP_POINT="$COMP_POINT"             COMP_TYPE="$COMP_TYPE"             _ARGCOMPLETE_COMP_WORDBREAKS="$COMP_WORDBREAKS"             _ARGCOMPLETE=$ARGCOMPLETE             _ARGCOMPLETE_SUPPRESS_SPACE=1             __python_argcomplete_run "$executable" "${COMP_WORDS[@]:1:ARGCOMPLETE-1}"));
        if [[ $? != 0 ]]; then
            unset COMPREPLY;
        else
            if [[ "$COMPREPLY" =~ [=/:]$ ]]; then
                compopt -o nospace;
            fi;
        fi;
    else
        type -t _completion_loader | grep -q 'function' && _completion_loader "$@";
    fi
}
_quote_readline_by_ref () 
{ 
    if [[ $1 == \'* ]]; then
        printf -v $2 %s "${1:1}";
    else
        printf -v $2 %q "$1";
    fi;
    [[ ${!2} == \$* ]] && eval $2=${!2}
}
_realcommand () 
{ 
    type -P "$1" > /dev/null && { 
        if type -p realpath > /dev/null; then
            realpath "$(type -P "$1")";
        else
            if type -p greadlink > /dev/null; then
                greadlink -f "$(type -P "$1")";
            else
                if type -p readlink > /dev/null; then
                    readlink -f "$(type -P "$1")";
                else
                    type -P "$1";
                fi;
            fi;
        fi
    }
}
_rl_enabled () 
{ 
    [[ "$(bind -v)" == *$1+([[:space:]])on* ]]
}
_root_command () 
{ 
    local PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin;
    local root_command=$1;
    _command
}
_samba_debuglevel () 
{ 
    COMPREPLY=($(compgen -W '{0..10}' -- "$cur"))
}
_samba_domains () 
{ 
    if [[ -n ${COMP_SAMBA_SCAN:-} ]]; then
        COMPREPLY=($(compgen -W '$(smbtree -N -D)' -- "$cur"));
    fi
}
_samba_hosts () 
{ 
    if [[ -n ${COMP_SAMBA_SCAN:-} ]]; then
        COMPREPLY=($(compgen -W "$(
            smbtree -N -S |
                command sed -ne 's/^[[:space:]]*\\\\*\([^[:space:]]*\).*/\1/p'
        )" -- "$cur"));
    fi
}
_samba_resolve_order () 
{ 
    COMPREPLY=($(compgen -W 'lmhosts host wins bcast' -- "$cur"))
}
_samba_signing () 
{ 
    COMPREPLY=($(compgen -W 'on off required' -- "$cur"))
}
_samba_sockopts () 
{ 
    COMPREPLY=($(compgen -W 'SO_KEEPALIVE SO_REUSEADDR SO_BROADCAST
        TCP_NODELAY IPTOS_LOWDELAY IPTOS_THROUGHPUT SO_SNDBUF SO_RCVBUF
        SO_SNDLOWAT SO_RCVLOWAT' -- "$cur"))
}
_scl () 
{ 
    local cur actions cur_action collections;
    COMPREPLY=();
    cur="${COMP_WORDS[COMP_CWORD]}";
    actions="enable run load unload list-collections list-packages man register deregister --help";
    collections=`scl list-collections`;
    if ((COMP_CWORD == 1)); then
        COMPREPLY=($(compgen -W "${actions}" -- ${cur}));
        return 0;
    fi;
    if ((COMP_CWORD > 3)); then
        for word in "${COMP_WORDS[@]}";
        do
            if [[ ${word} == \'* || ${word} == \"* || ${word} == "--" ]]; then
                return 0;
            fi;
        done;
    fi;
    if ((COMP_CWORD >= 2)); then
        cur_action="${COMP_WORDS[1]}";
        case "$cur_action" in 
            list-collections | list-enabled | --help)
                return 0
            ;;
            list-packages | man)
                if ((COMP_CWORD == 2)); then
                    COMPREPLY=($(compgen -W  "$collections" -- ${cur}));
                fi;
                return 0
            ;;
            deregister)
                if ((COMP_CWORD == 2)); then
                    COMPREPLY=($(compgen -W  "$collections --force -f" -- ${cur}));
                fi;
                if [ "$COMP_CWORD" -eq 3 -a "(" "${COMP_WORDS[2]}" == "--force" -o "${COMP_WORDS[2]}" == "-f" ")" ]; then
                    COMPREPLY=($(compgen -W  "$collections" -- ${cur}));
                fi;
                return 0
            ;;
            register)
                compopt -o plusdirs;
                if ((COMP_CWORD == 2)); then
                    COMPREPLY=($(compgen -A  directory -- ${cur}));
                fi;
                return 0
            ;;
            run | enable)
                if ((COMP_CWORD == 2)); then
                    COMPREPLY=($(compgen -W  "$collections -x --exec" -- ${cur}));
                else
                    COMPREPLY=($(compgen -W  "$collections" -- ${cur}));
                fi;
                return 0
            ;;
            load | unload)
                COMPREPLY=($(compgen -W  "$collections" -- ${cur}));
                return 0
            ;;
            *)

            ;;
        esac;
    fi
}
_service () 
{ 
    local cur prev words cword;
    _init_completion || return;
    ((cword > 2)) && return;
    if [[ $cword -eq 1 && $prev == ?(*/)service ]]; then
        _services;
        [[ -e /etc/mandrake-release ]] && _xinetd_services;
    else
        local sysvdirs;
        _sysvdirs;
        COMPREPLY=($(compgen -W '`command sed -e "y/|/ /" \
            -ne "s/^.*\(U\|msg_u\)sage.*{\(.*\)}.*$/\2/p" \
            ${sysvdirs[0]}/${prev##*/} 2>/dev/null` start stop' -- "$cur"));
    fi
}
_services () 
{ 
    local sysvdirs;
    _sysvdirs;
    local IFS=' 	
' reset=$(shopt -p nullglob);
    shopt -s nullglob;
    COMPREPLY=($(printf '%s\n' ${sysvdirs[0]}/!($_backup_glob|functions|README)));
    $reset;
    COMPREPLY+=($({
        systemctl list-units --full --all ||
            systemctl list-unit-files
    } 2>/dev/null |
        awk '$1 ~ /\.service$/ { sub("\\.service$", "", $1); print $1 }'));
    if [[ -x /sbin/upstart-udev-bridge ]]; then
        COMPREPLY+=($(initctl list 2>/dev/null | cut -d' ' -f1));
    fi;
    COMPREPLY=($(compgen -W '${COMPREPLY[@]#${sysvdirs[0]}/}' -- "$cur"))
}
_shells () 
{ 
    local shell rest;
    while read -r shell rest; do
        [[ $shell == /* && $shell == "$cur"* ]] && COMPREPLY+=($shell);
    done 2> /dev/null < /etc/shells
}
_signals () 
{ 
    local -a sigs=($(compgen -P "${1-}" -A signal "SIG${cur#${1-}}"));
    COMPREPLY+=("${sigs[@]/#${1-}SIG/${1-}}")
}
_smbcacls () 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    case $prev in 
        --configfile | --authentication-file | -!(-*)[As])
            _filedir;
            return
        ;;
        --log-basename | -!(-*)l)
            _filedir -d;
            return
        ;;
        --debuglevel | -!(-*)d)
            _samba_debuglevel;
            return
        ;;
        --signing)
            _samba_signing;
            return
        ;;
        --socket-options | -!(-*)O)
            _samba_sockopts;
            return
        ;;
        --workgroup | -!(-*)W)
            _samba_domains;
            return
        ;;
        --help | --usage | --delete | --modify | --add | --set | --chown | --chgrp | --netbiosname | --scope | --user | -!(-*)[?DMaSCGniU])
            return
        ;;
    esac;
    $split && return;
    if [[ $cur == -* ]]; then
        COMPREPLY=($(compgen -W '$(_parse_help "$1")' -- "$cur"));
        [[ ${COMPREPLY-} == *= ]] && compopt -o nospace;
    fi
}
_smbclient () 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    case $prev in 
        --name-resolve | -!(-*)R)
            _samba_resolve_order;
            return
        ;;
        -!(-*)t)
            COMPREPLY=($(compgen -W 'SJIS EUC JIS7 JIS8 JUNET HEX CAP'                 -- "$cur"));
            return
        ;;
        --configfile | --authentication-file | -!(-*)[sA])
            _filedir;
            return
        ;;
        --log-basename | --directory | -!(-*)[lD])
            _filedir -d;
            return
        ;;
        --socket-options | -!(-*)O)
            _samba_sockopts;
            return
        ;;
        -!(-*)T)
            COMPREPLY=($(compgen -W 'c x I X F b g q r N a' -- "$cur"));
            return
        ;;
        --workgroup | -!(-*)W)
            _samba_domains;
            return
        ;;
        --debuglevel | -!(-*)d)
            _samba_debuglevel;
            return
        ;;
        --list | -!(-*)L)
            _samba_hosts;
            return
        ;;
        --signing | -!(-*)S)
            _samba_signing;
            return
        ;;
        --port | --message | --ip-address | --send-buffer | --user | --netbiosname | --scope | --tar | --command | --max-protocol | -!(-*)[pMIbUniTcm])
            return
        ;;
        --help | --version | -!(-*)[?V])
            return
        ;;
    esac;
    $split && return;
    if [[ $cur == -* ]]; then
        COMPREPLY=($(compgen -W '$(_parse_help "$1")' -- "$cur"));
        [[ ${COMPREPLY-} == *= ]] && compopt -o nospace;
    fi
}
_smbcquotas () 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    case $prev in 
        --configfile | --authentication-file | -!(-*)[sA])
            _filedir;
            return
        ;;
        --log-basename | -!(-*)l)
            _filedir -d;
            return
        ;;
        --debuglevel | -!(-*)d)
            _samba_debuglevel;
            return
        ;;
        --signing)
            _samba_signing;
            return
        ;;
        --help | --usage | --user | --set | -!(-*)[?UuS])
            return
        ;;
    esac;
    $split && return;
    if [[ $cur == -* ]]; then
        COMPREPLY=($(compgen -W '$(_parse_help "$1")' -- "$cur"));
        [[ ${COMPREPLY-} == *= ]] && compopt -o nospace;
    fi
}
_smbget () 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    case $prev in 
        --outputfile | --rcfile | -!(-*)[of])
            _filedir;
            return
        ;;
        --debuglevel | -!(-*)d)
            _samba_debuglevel;
            return
        ;;
        --workgroup | -!(-*)w)
            _samba_domains;
            return
        ;;
        --username | --password | --blocksize | -!(-*)[upb])
            return
        ;;
    esac;
    $split && return;
    if [[ $cur == -* ]]; then
        COMPREPLY=($(compgen -W '$(_parse_help "$1")' -- "$cur"));
        [[ ${COMPREPLY-} == *= ]] && compopt -o nospace;
    fi
}
_smbpasswd () 
{ 
    local cur prev words cword;
    _init_completion || return;
    case $prev in 
        -*r)
            _samba_hosts;
            return
        ;;
        -*R)
            _samba_resolve_order;
            return
        ;;
        -*c)
            _filedir;
            return
        ;;
        -*D)
            _samba_debuglevel;
            return
        ;;
        -*[Uhw])
            return
        ;;
    esac;
    if [[ $cur == -* ]]; then
        COMPREPLY=($(compgen -W '$(_parse_help "$1" -h)' -- "$cur"));
    fi
}
_smbtar () 
{ 
    local cur prev words cword;
    _init_completion || return;
    case $prev in 
        -*[rt])
            _filedir tar;
            return
        ;;
        -*s)
            _samba_hosts;
            return
        ;;
        -*l)
            _samba_debuglevel;
            return
        ;;
        -*N)
            _filedir;
            return
        ;;
        -*[pxbdu])
            return
        ;;
    esac;
    if [[ $cur == -* ]]; then
        COMPREPLY=($(compgen -W '$(_parse_help "$1")' -- "$cur"));
    fi
}
_smbtree () 
{ 
    local cur prev words cword split;
    _init_completion -s || return;
    case $prev in 
        --configfile | --authentication-file | -!(-*)[sA])
            _filedir;
            return
        ;;
        --log-basename | -!(-*)l)
            _filedir -d;
            return
        ;;
        --debuglevel | -!(-*)d)
            _samba_debuglevel;
            return
        ;;
        --signing | -!(-*)S)
            _samba_signing;
            return
        ;;
        --help | --usage | --user | -!(-*)[?U])
            return
        ;;
    esac;
    $split && return;
    if [[ $cur == -* ]]; then
        COMPREPLY=($(compgen -W '$(_parse_help "$1")' -- "$cur"));
        [[ ${COMPREPLY-} == *= ]] && compopt -o nospace;
    fi
}
_split_longopt () 
{ 
    if [[ $cur == --?*=* ]]; then
        prev="${cur%%?(\\)=*}";
        cur="${cur#*=}";
        return 0;
    fi;
    return 1
}
_sysfs_get_netdevs () 
{ 
    COMPREPLY+=($( compgen -W "$( ls /sys/class/net 2>/dev/null )" --         "$cur" ))
}
_sysvdirs () 
{ 
    sysvdirs=();
    [[ -d /etc/rc.d/init.d ]] && sysvdirs+=(/etc/rc.d/init.d);
    [[ -d /etc/init.d ]] && sysvdirs+=(/etc/init.d);
    [[ -f /etc/slackware-version ]] && sysvdirs=(/etc/rc.d);
    return 0
}
_terms () 
{ 
    COMPREPLY+=($(compgen -W "$({
        command sed -ne 's/^\([^[:space:]#|]\{2,\}\)|.*/\1/p' /etc/termcap
        {
            toe -a || toe
        } | awk '{ print $1 }'
        find /{etc,lib,usr/lib,usr/share}/terminfo/? -type f -maxdepth 1 |
            awk -F/ '{ print $NF }'
    } 2>/dev/null)" -- "$cur"))
}
_tilde () 
{ 
    local result=0;
    if [[ ${1-} == \~* && $1 != */* ]]; then
        COMPREPLY=($(compgen -P '~' -u -- "${1#\~}"));
        result=${#COMPREPLY[@]};
        ((result > 0)) && compopt -o filenames 2> /dev/null;
    fi;
    return $result
}
_uids () 
{ 
    if type getent &> /dev/null; then
        COMPREPLY=($(compgen -W '$(getent passwd | cut -d: -f3)' -- "$cur"));
    else
        if type perl &> /dev/null; then
            COMPREPLY=($(compgen -W '$(perl -e '"'"'while (($uid) = (getpwent)[2]) { print $uid . "\n" }'"'"')' -- "$cur"));
        else
            COMPREPLY=($(compgen -W '$(cut -d: -f3 /etc/passwd)' -- "$cur"));
        fi;
    fi
}
_upvar () 
{ 
    echo "bash_completion: $FUNCNAME: deprecated function," "use _upvars instead" 1>&2;
    if unset -v "$1"; then
        if (($# == 2)); then
            eval $1=\"\$2\";
        else
            eval $1=\(\"\$"{@:2}"\"\);
        fi;
    fi
}
_upvars () 
{ 
    if ! (($#)); then
        echo "bash_completion: $FUNCNAME: usage: $FUNCNAME" "[-v varname value] | [-aN varname [value ...]] ..." 1>&2;
        return 2;
    fi;
    while (($#)); do
        case $1 in 
            -a*)
                [[ -n ${1#-a} ]] || { 
                    echo "bash_completion: $FUNCNAME:" "\`$1': missing number specifier" 1>&2;
                    return 1
                };
                printf %d "${1#-a}" &> /dev/null || { 
                    echo bash_completion: "$FUNCNAME: \`$1': invalid number specifier" 1>&2;
                    return 1
                };
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\(\"\$"{@:3:${1#-a}}"\"\) && shift $((${1#-a} + 2)) || { 
                    echo bash_completion: "$FUNCNAME: \`$1${2+ }$2': missing argument(s)" 1>&2;
                    return 1
                }
            ;;
            -v)
                [[ -n "$2" ]] && unset -v "$2" && eval $2=\"\$3\" && shift 3 || { 
                    echo "bash_completion: $FUNCNAME: $1:" "missing argument(s)" 1>&2;
                    return 1
                }
            ;;
            *)
                echo "bash_completion: $FUNCNAME: $1: invalid option" 1>&2;
                return 1
            ;;
        esac;
    done
}
_usb_ids () 
{ 
    COMPREPLY+=($(compgen -W         "$(PATH="$PATH:/sbin" lsusb | awk '{print $6}')" -- "$cur"))
}
_user_at_host () 
{ 
    local cur prev words cword;
    _init_completion -n : || return;
    if [[ $cur == *@* ]]; then
        _known_hosts_real "$cur";
    else
        COMPREPLY=($(compgen -u -S @ -- "$cur"));
        compopt -o nospace;
    fi
}
_usergroup () 
{ 
    if [[ $cur == *\\\\* || $cur == *:*:* ]]; then
        return;
    else
        if [[ $cur == *\\:* ]]; then
            local prefix;
            prefix=${cur%%*([^:])};
            prefix=${prefix//\\/};
            local mycur="${cur#*[:]}";
            if [[ ${1-} == -u ]]; then
                _allowed_groups "$mycur";
            else
                local IFS='
';
                COMPREPLY=($(compgen -g -- "$mycur"));
            fi;
            COMPREPLY=($(compgen -P "$prefix" -W "${COMPREPLY[@]}"));
        else
            if [[ $cur == *:* ]]; then
                local mycur="${cur#*:}";
                if [[ ${1-} == -u ]]; then
                    _allowed_groups "$mycur";
                else
                    local IFS='
';
                    COMPREPLY=($(compgen -g -- "$mycur"));
                fi;
            else
                if [[ ${1-} == -u ]]; then
                    _allowed_users "$cur";
                else
                    local IFS='
';
                    COMPREPLY=($(compgen -u -- "$cur"));
                fi;
            fi;
        fi;
    fi
}
_userland () 
{ 
    local userland=$(uname -s);
    [[ $userland == @(Linux|GNU/*) ]] && userland=GNU;
    [[ $userland == "$1" ]]
}
_variables () 
{ 
    if [[ $cur =~ ^(\$(\{[!#]?)?)([A-Za-z0-9_]*)$ ]]; then
        if [[ $cur == '${'* ]]; then
            local arrs vars;
            vars=($(compgen -A variable -P ${BASH_REMATCH[1]} -S '}' -- ${BASH_REMATCH[3]}));
            arrs=($(compgen -A arrayvar -P ${BASH_REMATCH[1]} -S '[' -- ${BASH_REMATCH[3]}));
            if ((${#vars[@]} == 1 && ${#arrs[@]} != 0)); then
                compopt -o nospace;
                COMPREPLY+=(${arrs[*]});
            else
                COMPREPLY+=(${vars[*]});
            fi;
        else
            COMPREPLY+=($(compgen -A variable -P '$' -- "${BASH_REMATCH[3]}"));
        fi;
        return 0;
    else
        if [[ $cur =~ ^(\$\{[#!]?)([A-Za-z0-9_]*)\[([^]]*)$ ]]; then
            local IFS='
';
            COMPREPLY+=($(compgen -W '$(printf %s\\n "${!'${BASH_REMATCH[2]}'[@]}")'             -P "${BASH_REMATCH[1]}${BASH_REMATCH[2]}[" -S ']}' -- "${BASH_REMATCH[3]}"));
            if [[ ${BASH_REMATCH[3]} == [@*] ]]; then
                COMPREPLY+=("${BASH_REMATCH[1]}${BASH_REMATCH[2]}[${BASH_REMATCH[3]}]}");
            fi;
            __ltrim_colon_completions "$cur";
            return 0;
        else
            if [[ $cur =~ ^\$\{[#!]?[A-Za-z0-9_]*\[.*\]$ ]]; then
                COMPREPLY+=("$cur}");
                __ltrim_colon_completions "$cur";
                return 0;
            else
                case ${prev-} in 
                    TZ)
                        cur=/usr/share/zoneinfo/$cur;
                        _filedir;
                        for i in "${!COMPREPLY[@]}";
                        do
                            if [[ ${COMPREPLY[i]} == *.tab ]]; then
                                unset 'COMPREPLY[i]';
                                continue;
                            else
                                if [[ -d ${COMPREPLY[i]} ]]; then
                                    COMPREPLY[i]+=/;
                                    compopt -o nospace;
                                fi;
                            fi;
                            COMPREPLY[i]=${COMPREPLY[i]#/usr/share/zoneinfo/};
                        done;
                        return 0
                    ;;
                    TERM)
                        _terms;
                        return 0
                    ;;
                    LANG | LC_*)
                        COMPREPLY=($(compgen -W '$(locale -a 2>/dev/null)'                     -- "$cur"));
                        return 0
                    ;;
                esac;
            fi;
        fi;
    fi;
    return 1
}
_vdostats () 
{ 
    local opts cur;
    _init_completion || return;
    COMPREPLY=();
    opts="--help --all --human-readable --si --verbose --version";
    cur="${COMP_WORDS[COMP_CWORD]}";
    case "${cur}" in 
        *)
            COMPREPLY=($(compgen -W "${opts}" -- ${cur}))
        ;;
    esac
}
_xfunc () 
{ 
    set -- "$@";
    local srcfile=$1;
    shift;
    declare -F $1 &> /dev/null || __load_completion "$srcfile";
    "$@"
}
_xinetd_services () 
{ 
    local xinetddir=${BASHCOMP_XINETDDIR:-/etc/xinetd.d};
    if [[ -d $xinetddir ]]; then
        local IFS=' 	
' reset=$(shopt -p nullglob);
        shopt -s nullglob;
        local -a svcs=($(printf '%s\n' $xinetddir/!($_backup_glob)));
        $reset;
        ((!${#svcs[@]})) || COMPREPLY+=($(compgen -W '${svcs[@]#$xinetddir/}' -- "${cur-}"));
    fi
}
cdi () 
{ 
    cd "$1";
    ls --color=auto --color
}
clearLmod () 
{ 
    module --force purge;
    eval $($LMOD_DIR/clearLMOD_cmd --shell bash --full "$@")
}
clearMT () 
{ 
    eval $($LMOD_DIR/clearLMOD_cmd --shell bash --simple)
}
command_not_found_handle () 
{ 
    local runcnf=1;
    local retval=127;
    [[ $- == *"i"* ]] || runcnf=0;
    [[ ! -S /run/dbus/system_bus_socket ]] && runcnf=0;
    [[ ! -x '/usr/libexec/packagekitd' ]] && runcnf=0;
    [[ -n ${COMP_CWORD-} ]] && runcnf=0;
    [[ ! -x '/usr/libexec/pk-command-not-found' ]] && runcnf=0;
    if [ $runcnf -eq 1 ]; then
        '/usr/libexec/pk-command-not-found' "$@";
        retval=$?;
    else
        if [[ -n "${BASH_VERSION-}" ]]; then
            printf 'bash: %s%s\n' "${1:+$1: }" "$(gettext PackageKit 'command not found')" 1>&2;
        fi;
    fi;
    return $retval
}
dequote () 
{ 
    eval printf %s "$1" 2> /dev/null
}
gawklibpath_append () 
{ 
    [ -z "$AWKLIBPATH" ] && AWKLIBPATH=`gawk 'BEGIN {print ENVIRON["AWKLIBPATH"]}'`;
    export AWKLIBPATH="$AWKLIBPATH:$*"
}
gawklibpath_default () 
{ 
    unset AWKLIBPATH;
    export AWKLIBPATH=`gawk 'BEGIN {print ENVIRON["AWKLIBPATH"]}'`
}
gawklibpath_prepend () 
{ 
    [ -z "$AWKLIBPATH" ] && AWKLIBPATH=`gawk 'BEGIN {print ENVIRON["AWKLIBPATH"]}'`;
    export AWKLIBPATH="$*:$AWKLIBPATH"
}
gawkpath_append () 
{ 
    [ -z "$AWKPATH" ] && AWKPATH=`gawk 'BEGIN {print ENVIRON["AWKPATH"]}'`;
    export AWKPATH="$AWKPATH:$*"
}
gawkpath_default () 
{ 
    unset AWKPATH;
    export AWKPATH=`gawk 'BEGIN {print ENVIRON["AWKPATH"]}'`
}
gawkpath_prepend () 
{ 
    [ -z "$AWKPATH" ] && AWKPATH=`gawk 'BEGIN {print ENVIRON["AWKPATH"]}'`;
    export AWKPATH="$*:$AWKPATH"
}
ml () 
{ 
    eval "$($LMOD_DIR/ml_cmd "$@")"
}
module () 
{ 
    if [ -z "${LMOD_SH_DBG_ON+x}" ]; then
        case "$-" in 
            *v*x*)
                __lmod_sh_dbg='vx'
            ;;
            *v*)
                __lmod_sh_dbg='v'
            ;;
            *x*)
                __lmod_sh_dbg='x'
            ;;
        esac;
    fi;
    if [ -n "${__lmod_sh_dbg:-}" ]; then
        set +$__lmod_sh_dbg;
        echo "Shell debugging temporarily silenced: export LMOD_SH_DBG_ON=1 for Lmod's output" 1>&2;
    fi;
    eval "$($LMOD_CMD shell "$@")" && eval "$(${LMOD_SETTARG_CMD:-:} -s sh)";
    __lmod_my_status=$?;
    if [ -n "${__lmod_sh_dbg:-}" ]; then
        echo "Shell debugging restarted" 1>&2;
        set -$__lmod_sh_dbg;
    fi;
    unset __lmod_sh_dbg;
    return $__lmod_my_status
}
quote () 
{ 
    local quoted=${1//\'/\'\\\'\'};
    printf "'%s'" "$quoted"
}
quote_readline () 
{ 
    local ret;
    _quote_readline_by_ref "$1" ret;
    printf %s "$ret"
}
scl () 
{ 
    if [ "$1" = "load" -o "$1" = "unload" ]; then
        eval "module $@";
    else
        /usr/bin/scl "$@";
    fi
}
up () 
{ 
    UPPATH='..';
    if [ -n "$1" ] && [ "$1" -gt 0 ] && [ "$1" -lt 10 ]; then
        for ((d=1; d<$1; d++))
        do
            UPPATH+='/..';
        done;
        cd $UPPATH;
        pwd;
    else
        if [ -z "$1" ]; then
            cd $UPPATH;
            pwd;
        else
            echo "Usage: 'up [N]', where N is in the range 1..10";
        fi;
    fi
}
which () 
{ 
    ( alias;
    eval ${which_declare} ) | /usr/bin/which --tty-only --read-alias --read-functions --show-tilde --show-dot $@
}
xSetTitleLmod () 
{ 
    builtin echo -n -e "\033]2;$1\007"
}
